```python
from typing import List, Union
import re

class Calculator:
    """
    Console-based arithmetic calculator conforming to ISO/IEC 25010 standards.
    Supports +, -, *, / operations, handles parentheses, operator precedence,
    and both integer and floating-point numbers (including negatives).
    """

    # Define allowed operators and their precedence/associativity
    OPERATORS = {
        '+': {'precedence': 1, 'associativity': 'left'},
        '-': {'precedence': 1, 'associativity': 'left'},
        '*': {'precedence': 2, 'associativity': 'left'},
        '/': {'precedence': 2, 'associativity': 'left'},
    }
    # Regular expression for tokenizing the expression
    TOKEN_REGEX = re.compile(
        r'\s*('
        r'(?P<number>-?\d+(\.\d+)?)'
        r'|(?P<operator>[+\-*/])'
        r'|(?P<paren>[()])'
        r')\s*'
    )

    def calculate(self, expression: str) -> float:
        """
        Evaluate an arithmetic expression and return its result as a float.
        :param expression: The arithmetic expression to evaluate as a string.
        :raises ValueError: If the expression contains invalid syntax or characters.
        :raises ZeroDivisionError: If division by zero occurs.
        """
        tokens = self._tokenize(expression)
        rpn = self._to_rpn(tokens)
        result = self._eval_rpn(rpn)
        return result

    def _tokenize(self, expression: str) -> List[Union[str, float]]:
        """
        Tokenize the input arithmetic expression.
        :param expression: Expression string.
        :return: List of tokens (numbers as float, operators, parentheses).
        :raises ValueError: For invalid characters or malformed numbers.
        """
        tokens = []
        pos = 0
        prev_token_type = None
        while pos < len(expression):
            match = self.TOKEN_REGEX.match(expression, pos)
            if not match:
                # Try to find the invalid character
                char = expression[pos]
                if char.isspace():
                    pos += 1
                    continue
                raise ValueError(f"Invalid character '{char}' at position {pos + 1}.")
            if match.group('number'):
                # Prevent two numbers without an operator in between
                if prev_token_type == 'number':
                    raise ValueError(f"Invalid input: unexpected number at position {pos + 1}.")
                tokens.append(float(match.group('number')))
                prev_token_type = 'number'
            elif match.group('operator'):
                # Check for invalid placement of operators (e.g., "**", "++")
                if prev_token_type == 'operator' and match.group('operator') != '-':
                    raise ValueError(f"Invalid input: consecutive operators at position {pos + 1}.")
                tokens.append(match.group('operator'))
                prev_token_type = 'operator'
            elif match.group('paren'):
                tokens.append(match.group('paren'))
                prev_token_type = 'paren'
            pos = match.end()
        self._validate_parentheses(tokens)
        return self._normalize_tokens(tokens)

    def _validate_parentheses(self, tokens: List[Union[str, float]]) -> None:
        """
        Validate parentheses are balanced.
        :param tokens: List of tokens.
        :raises ValueError: If parentheses are unbalanced.
        """
        stack = []
        for index, token in enumerate(tokens):
            if token == '(':
                stack.append(index)
            elif token == ')':
                if not stack:
                    raise ValueError("Unbalanced parenthesis: extra closing ')' detected.")
                stack.pop()
        if stack:
            raise ValueError("Unbalanced parenthesis: missing closing ')'.")

    def _normalize_tokens(self, tokens: List[Union[str, float]]) -> List[Union[str, float]]:
        """
        Normalize tokens by handling unary negative numbers.
        This ensures that unary '-' is appropriately detected as negation.
        :param tokens: List of tokens.
        :return: Normalized list with unary negatives merged with number.
        """
        normalized = []
        i = 0
        while i < len(tokens):
            token = tokens[i]
            if token == '-' and (
                i == 0 or (isinstance(tokens[i - 1], str) and tokens[i - 1] in self.OPERATORS) or tokens[i - 1] == '('
            ):
                # Negative number detection
                if i + 1 < len(tokens) and isinstance(tokens[i + 1], float):
                    normalized.append(-tokens[i + 1])
                    i += 2
                    continue
                else:
                    raise ValueError("Invalid syntax: '-' not followed by a number at position {}".format(i + 1))
            normalized.append(token)
            i += 1
        return normalized

    def _to_rpn(self, tokens: List[Union[str, float]]) -> List[Union[str, float]]:
        """
        Convert token list from infix to postfix notation (RPN) using the shunting yard algorithm.
        :param tokens: List of tokens (numbers, operators, parentheses).
        :return: List of tokens in RPN order.
        """
        output = []
        operator_stack = []
        for token in tokens:
            if isinstance(token, float):
                output.append(token)
            elif token in self.OPERATORS:
                # Handle operator precedence and associativity
                while operator_stack:
                    top = operator_stack[-1]
                    if top in self.OPERATORS:
                        curr_op = self.OPERATORS[token]
                        top_op = self.OPERATORS[top]
                        if (curr_op['associativity'] == 'left' and curr_op['precedence'] <= top_op['precedence']) or \
                           (curr_op['associativity'] == 'right' and curr_op['precedence'] < top_op['precedence']):
                            output.append(operator_stack.pop())
                            continue
                    break
                operator_stack.append(token)
            elif token == '(':
                operator_stack.append(token)
            elif token == ')':
                # Pop until left parenthesis
                while operator_stack:
                    op = operator_stack.pop()
                    if op == '(':
                        break
                    output.append(op)
                else:
                    raise ValueError("Unbalanced parenthesis detected during processing.")
            else:
                raise ValueError(f"Invalid token {token}.")
        # Pop any remaining operators
        while operator_stack:
            op = operator_stack.pop()
            if op in ('(', ')'):
                raise ValueError("Unbalanced parenthesis detected after processing.")
            output.append(op)
        return output

    def _eval_rpn(self, tokens: List[Union[str, float]]) -> float:
        """
        Evaluate a list of tokens in RPN order.
        :param tokens: List of RPN tokens.
        :return: Computed float result.
        :raises ZeroDivisionError: When division by zero is encountered.
        """
        stack: List[float] = []
        for token in tokens:
            if isinstance(token, float):
                stack.append(token)
            elif token in self.OPERATORS:
                try:
                    right = stack.pop()
                    left = stack.pop()
                except IndexError:
                    raise ValueError("Invalid syntax: insufficient values for operation.")
                result = self._apply_operator(left, right, token)
                stack.append(result)
            else:
                raise ValueError(f"Invalid token in RPN: {token}")
        if len(stack) != 1:
            raise ValueError("Invalid expression: too many or too few values.")
        return stack[0]

    def _apply_operator(self, left: float, right: float, operator: str) -> float:
        """
        Apply a binary operator to two operands, checking for division by zero.
        :param left: Left operand.
        :param right: Right operand.
        :param operator: Operator string.
        :return: Result of operation.
        :raises ZeroDivisionError: Division by zero.
        """
        if operator == '+':
            return left + right
        elif operator == '-':
            return left - right
        elif operator == '*':
            return left * right
        elif operator == '/':
            if right == 0:
                raise ZeroDivisionError("Division by zero.")
            return left / right
        else:
            raise ValueError(f"Unknown operator '{operator}'.")

# Sample test code (can be removed or modified as per requirement)
if __name__ == "__main__":
    calc = Calculator()
    expressions = [
        "2 + 3 * 4",
        "-2 + (3.5 * 2)",
        "((1+2)*(3+4)) / 5",
        "-(2 + 3) * 4",
        "2 + -2",
        "(1 + 2) * (3 - 4) / -5",
        "3.5 + 4 * 10 / (2 - 3)",
        "5 / 0",           # This should raise ZeroDivisionError
        "2 + (3",          # This should raise ValueError for unbalanced parentheses
        "abc + 1",         # This should raise ValueError for invalid characters
        "5 * * 2",         # This should raise ValueError for invalid syntax
    ]

    for expr in expressions:
        try:
            result = calc.calculate(expr)
            print(f"Expression: {expr} = {result}")
        except Exception as e:
            print(f"Expression: {expr} -> Error: {e}")
```
**Notes:**
- This code implements a stack-based shunting yard algorithm for parsing and evaluating arithmetic expressions.
- It handles unary minus, floating-point numbers, negative numbers, operator precedence, parentheses, and robust input validation.
- Errors such as unbalanced parentheses, invalid characters, division by zero, and other syntactic issues are signaled using appropriate Python exceptions.
- The class is modular, well-documented, and easily testable; each stage (tokenizing, parsing, evaluating) is separate and clear.
- The test cases at the bottom demonstrate correct usage and error handling (they may be removed for production use).
