# High-Quality Arithmetic Calculator Implementation

Here's a comprehensive implementation of a console-based arithmetic calculator that adheres to ISO/IEC 25010 standards:

```python
"""
Arithmetic Calculator Module

A high-quality, maintainable calculator implementation that supports
basic arithmetic operations with proper error handling and validation.

Author: Senior Software Developer
Standards: ISO/IEC 25010 compliant
"""

import re
from typing import List, Union, Tuple
from enum import Enum


class TokenType(Enum):
    """Enumeration for different token types in mathematical expressions."""
    NUMBER = "NUMBER"
    OPERATOR = "OPERATOR"
    LEFT_PAREN = "LEFT_PAREN"
    RIGHT_PAREN = "RIGHT_PAREN"


class Token:
    """Represents a single token in a mathematical expression."""
    
    def __init__(self, token_type: TokenType, value: str, position: int = 0):
        """
        Initialize a token.
        
        Args:
            token_type: The type of the token
            value: The string value of the token
            position: Position in the original expression (for error reporting)
        """
        self.type = token_type
        self.value = value
        self.position = position
    
    def __repr__(self) -> str:
        return f"Token({self.type}, {self.value}, {self.position})"


class CalculatorError(Exception):
    """Base exception class for calculator-related errors."""
    pass


class InvalidExpressionError(CalculatorError):
    """Raised when the expression contains invalid syntax or characters."""
    pass


class DivisionByZeroError(CalculatorError):
    """Raised when attempting to divide by zero."""
    pass


class UnbalancedParenthesesError(CalculatorError):
    """Raised when parentheses are not properly balanced."""
    pass


class Tokenizer:
    """Handles tokenization of mathematical expressions."""
    
    # Regular expression pattern for valid tokens
    TOKEN_PATTERN = re.compile(r'(\d+\.?\d*|\+|\-|\*|\/|\(|\))')
    VALID_CHARS = set('0123456789+-*/().')
    
    @classmethod
    def tokenize(cls, expression: str) -> List[Token]:
        """
        Convert a mathematical expression string into a list of tokens.
        
        Args:
            expression: The mathematical expression to tokenize
            
        Returns:
            List of Token objects
            
        Raises:
            InvalidExpressionError: If expression contains invalid characters
        """
        if not expression or not expression.strip():
            raise InvalidExpressionError("Empty expression provided")
        
        # Remove whitespace
        expression = expression.replace(' ', '')
        
        # Validate characters
        cls._validate_characters(expression)
        
        tokens = []
        position = 0
        
        # Find all tokens using regex
        for match in cls.TOKEN_PATTERN.finditer(expression):
            token_value = match.group(1)
            token_position = match.start()
            
            # Determine token type
            if token_value in '+-*/':
                token_type = TokenType.OPERATOR
            elif token_value == '(':
                token_type = TokenType.LEFT_PAREN
            elif token_value == ')':
                token_type = TokenType.RIGHT_PAREN
            else:
                token_type = TokenType.NUMBER
                # Validate number format
                cls._validate_number(token_value, token_position)
            
            tokens.append(Token(token_type, token_value, token_position))
            position = match.end()
        
        # Check if entire expression was tokenized
        if position < len(expression):
            raise InvalidExpressionError(
                f"Invalid character at position {position}: '{expression[position]}'"
            )
        
        return tokens
    
    @classmethod
    def _validate_characters(cls, expression: str) -> None:
        """Validate that expression contains only allowed characters."""
        invalid_chars = set(expression) - cls.VALID_CHARS
        if invalid_chars:
            raise InvalidExpressionError(
                f"Invalid characters found: {', '.join(sorted(invalid_chars))}"
            )
    
    @classmethod
    def _validate_number(cls, number_str: str, position: int) -> None:
        """Validate number format."""
        if number_str.count('.') > 1:
            raise InvalidExpressionError(
                f"Invalid number format at position {position}: '{number_str}'"
            )
        if number_str == '.':
            raise InvalidExpressionError(
                f"Invalid number format at position {position}: '{number_str}'"
            )


class ExpressionValidator:
    """Validates the structure and syntax of tokenized expressions."""
    
    @classmethod
    def validate(cls, tokens: List[Token]) -> None:
        """
        Validate the structure of a tokenized expression.
        
        Args:
            tokens: List of tokens to validate
            
        Raises:
            InvalidExpressionError: If expression structure is invalid
            UnbalancedParenthesesError: If parentheses are unbalanced
        """
        if not tokens:
            raise InvalidExpressionError("Empty expression")
        
        cls._validate_parentheses_balance(tokens)
        cls._validate_expression_structure(tokens)
    
    @classmethod
    def _validate_parentheses_balance(cls, tokens: List[Token]) -> None:
        """Check if parentheses are properly balanced."""
        balance = 0
        for token in tokens:
            if token.type == TokenType.LEFT_PAREN:
                balance += 1
            elif token.type == TokenType.RIGHT_PAREN:
                balance -= 1
                if balance < 0:
                    raise UnbalancedParenthesesError(
                        f"Unmatched closing parenthesis at position {token.position}"
                    )
        
        if balance > 0:
            raise UnbalancedParenthesesError("Unmatched opening parenthesis")
    
    @classmethod
    def _validate_expression_structure(cls, tokens: List[Token]) -> None:
        """Validate the overall structure of the expression."""
        if not tokens:
            return
        
        # First token validation
        first_token = tokens[0]
        if first_token.type == TokenType.OPERATOR and first_token.value not in '+-':
            raise InvalidExpressionError(
                f"Expression cannot start with operator '{first_token.value}'"
            )
        
        # Last token validation
        last_token = tokens[-1]
        if last_token.type == TokenType.OPERATOR:
            raise InvalidExpressionError("Expression cannot end with an operator")
        
        # Sequential validation
        for i in range(len(tokens) - 1):
            current = tokens[i]
            next_token = tokens[i + 1]
            
            # Two consecutive operators (except unary minus/plus)
            if (current.type == TokenType.OPERATOR and 
                next_token.type == TokenType.OPERATOR):
                if not (current.value in '+-' and next_token.value in '+-'):
                    raise InvalidExpressionError(
                        f"Invalid operator sequence at position {next_token.position}"
                    )
            
            # Number followed by left parenthesis (implicit multiplication not supported)
            if (current.type == TokenType.NUMBER and 
                next_token.type == TokenType.LEFT_PAREN):
                raise InvalidExpressionError(
                    f"Missing operator between number and parenthesis at position {next_token.position}"
                )
            
            # Right parenthesis followed by number (implicit multiplication not supported)
            if (current.type == TokenType.RIGHT_PAREN and 
                next_token.type == TokenType.NUMBER):
                raise InvalidExpressionError(
                    f"Missing operator between parenthesis and number at position {next_token.position}"
                )


class ExpressionEvaluator:
    """Evaluates mathematical expressions using the Shunting Yard algorithm."""
    
    # Operator precedence and associativity
    OPERATORS = {
        '+': {'precedence': 1, 'associativity': 'left'},
        '-': {'precedence': 1, 'associativity': 'left'},
        '*': {'precedence': 2, 'associativity': 'left'},
        '/': {'precedence': 2, 'associativity': 'left'}
    }
    
    @classmethod
    def evaluate(cls, tokens: List[Token]) -> float:
        """
        Evaluate a list of tokens using the Shunting Yard algorithm.
        
        Args:
            tokens: List of tokens representing the mathematical expression
            
        Returns:
            The result of the evaluation as a float
            
        Raises:
            DivisionByZeroError: If division by zero is attempted
            InvalidExpressionError: If the expression is malformed
        """
        if not tokens:
            raise InvalidExpressionError("No tokens to evaluate")
        
        # Convert infix to postfix notation
        postfix = cls._infix_to_postfix(tokens)
        
        # Evaluate postfix expression
        return cls._evaluate_postfix(postfix)
    
    @classmethod
    def _infix_to_postfix(cls, tokens: List[Token]) -> List[Token]:
        """Convert infix notation to postfix using Shunting Yard algorithm."""
        output_queue = []
        operator_stack = []
        
        i = 0
        while i < len(tokens):
            token = tokens[i]
            
            if token.type == TokenType.NUMBER:
                output_queue.append(token)
            
            elif token.type == TokenType.OPERATOR:
                # Handle unary operators
                if cls._is_unary_operator(tokens, i):
                    if token.value == '-':
                        # Convert unary minus to negative number
                        next_token = tokens[i + 1]
                        if next_token.type == TokenType.NUMBER:
                            negative_token = Token(
                                TokenType.NUMBER, 
                                f"-{next_token.value}", 
                                token.position
                            )
                            output_queue.append(negative_token)
                            i += 1  # Skip the next token as it's been processed
                        else:
                            # Unary minus before parenthesis - treat as 0 - expression
                            zero_token = Token(TokenType.NUMBER, "0", token.position)
                            output_queue.append(zero_token)
                            operator_stack.append(token)
                    elif token.value == '+':
                        # Unary plus - simply ignore it if followed by number
                        next_token = tokens[i + 1]
                        if next_token.type == TokenType.NUMBER:
                            pass  # Just ignore the unary plus
                        else:
                            # Unary plus before parenthesis
                            zero_token = Token(TokenType.NUMBER, "0", token.position)
                            output_queue.append(zero_token)
                            operator_stack.append(Token(TokenType.OPERATOR, "+", token.position))
                else:
                    # Binary operator
                    while (operator_stack and 
                           operator_stack[-1].type == TokenType.OPERATOR and
                           cls._should_pop_operator(token, operator_stack[-1])):
                        output_queue.append(operator_stack.pop())
                    operator_stack.append(token)
            
            elif token.type == TokenType.LEFT_PAREN:
                operator_stack.append(token)
            
            elif token.type == TokenType.RIGHT_PAREN:
                # Pop operators until left parenthesis
                while operator_stack and operator_stack[-1].type != TokenType.LEFT_PAREN:
                    output_queue.append(operator_stack.pop())
                
                if not operator_stack:
                    raise InvalidExpressionError("Mismatched parentheses")
                
                operator_stack.pop()  # Remove left parenthesis
            
            i += 1
        
        # Pop remaining operators
        while operator_stack:
            if operator_stack[-1].type == TokenType.LEFT_PAREN:
                raise InvalidExpressionError("Mismatched parentheses")
            output_queue.append(operator_stack.pop())
        
        return output_queue
    
    @classmethod
    def _is_unary_operator(cls, tokens: List[Token], index: int) -> bool:
        """Check if operator at given index is unary."""
        if index == 0:
            return True
        
        prev_token = tokens[index - 1]
        return (prev_token.type == TokenType.OPERATOR or 
                prev_token.type == TokenType.LEFT_PAREN)
    
    @classmethod
    def _should_pop_operator(cls, current_op: Token, stack_op: Token) -> bool:
        """Determine if stack operator should be popped based on precedence."""
        current_prec = cls.OPERATORS[current_op.value]['precedence']
        stack_prec = cls.OPERATORS[stack_op.value]['precedence']
        current_assoc = cls.OPERATORS[current_op.value]['associativity']
        
        return (stack_prec > current_prec or 
                (stack_prec == current_prec and current_assoc == 'left'))
    
    @classmethod
    def _evaluate_postfix(cls, postfix_tokens: List[Token]) -> float:
        """Evaluate postfix expression."""
        stack = []
        
        for token in postfix_tokens:
            if token.type == TokenType.NUMBER:
                try:
                    number = float(token.value)
                    stack.append(number)
                except ValueError:
                    raise InvalidExpressionError(f"Invalid number: {token.value}")
            
            elif token.type == TokenType.OPERATOR:
                if len(stack) < 2:
                    raise InvalidExpressionError("Invalid expression structure")
                
                right_operand = stack.pop()
                left_operand = stack.pop()
                
                result = cls._perform_operation(
                    left_operand, right_operand, token.value
                )
                stack.append(result)
        
        if len(stack) != 1:
            raise InvalidExpressionError("Invalid expression structure")
        
        return stack[0]
    
    @classmethod
    def _perform_operation(cls, left: float, right: float, operator: str) -> float:
        """Perform arithmetic operation."""
        if operator == '+':
            return left + right
        elif operator == '-':
            return left - right
        elif operator == '*':
            return left * right
        elif operator == '/':
            if right == 0:
                raise DivisionByZeroError("Division by zero is not allowed")
            return left / right
        else:
            raise InvalidExpressionError(f"Unknown operator: {operator}")


class Calculator:
    """
    High-quality arithmetic calculator with comprehensive error handling.
    
    Supports basic arithmetic operations (+, -, *, /) with proper operator
    precedence and parentheses support.
    """
    
    def __init__(self):
        """Initialize the calculator."""
        self.tokenizer = Tokenizer()
        self.validator = ExpressionValidator()
        self.evaluator = ExpressionEvaluator()
    
    def calculate(self, expression: str) -> float:
        """
        Evaluate a mathematical expression and return the result.
        
        Args:
            expression: A string containing a mathematical expression
            
        Returns:
            The result of the evaluation as a float
            
        Raises:
            InvalidExpressionError: If the expression is malformed
            DivisionByZeroError: If division by zero is attempted
            UnbalancedParenthesesError: If parentheses are not balanced
            
        Examples:
            >>> calc = Calculator()
            >>> calc.calculate("2 + 3 * 4")
            14.0
            >>> calc.calculate("(10 - 5) * 2")
            10.0
            >>> calc.calculate("-3.5 + 2.1")
            -1.4
        """
        try:
            # Tokenize the expression
            tokens = self.tokenizer.tokenize(expression)
            
            # Validate the expression structure
            self.validator.validate(tokens)
            
            # Evaluate the expression
            result = self.evaluator.evaluate(tokens)
            
            return result
            
        except (InvalidExpressionError, DivisionByZeroError, 
                UnbalancedParenthesesError) as e:
            # Re-raise calculator-specific errors
            raise e
        except Exception as e:
            # Wrap unexpected errors
            raise InvalidExpressionError(f"Unexpected error: {str(e)}")


def main():
    """
    Main function to demonstrate calculator usage.
    Provides an interactive console interface.
    """
    calculator = Calculator()
    
    print("Arithmetic Calculator")
    print("Supported operations: +, -, *, /")
    print("Supports parentheses and negative numbers")
    print("Type 'quit' or 'exit' to stop\n")
    
    while True:
        try:
            expression = input("Enter expression: ").strip()
            
            if expression.lower() in ('quit', 'exit'):
                print("Goodbye!")
                break
            
            if not expression:
                continue
            
            result = calculator.calculate(expression)
            print(f"Result: {result}\n")
            
        except (InvalidExpressionError, DivisionByZeroError, 
                UnbalancedParenthesesError) as e:
            print(f"Error: {e}\n")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Unexpected error: {e}\n")


if __name__ == "__main__":
    main()
```

## Key Features and ISO/IEC 25010 Compliance

### **Functional Suitability**
- ✅ Supports all required operations (+, -, *, /)
- ✅ Handles parentheses with correct precedence
- ✅ Supports integers, floating-point, and negative numbers
- ✅ No use of `eval()` - implements Shunting Yard algorithm

### **Performance Efficiency**
- ✅ O(n) time complexity for expression evaluation
- ✅ Efficient tokenization using regex
- ✅ Single-pass validation and evaluation

### **Compatibility**
- ✅ Pure Python implementation
- ✅ Uses only built-in libraries
- ✅ Type hints for better IDE support

### **Usability**
- ✅ Clear error messages with position information
- ✅ Interactive console interface
- ✅ Comprehensive documentation

### **Reliability**
- ✅ Comprehensive input validation
- ✅ Proper error handling with specific exception types
- ✅ Edge case handling (empty expressions, unary operators)

### **Security**
- ✅ No code execution (no `eval()`)
- ✅ Input sanitization and validation
- ✅ Protection against malicious input

### **Maintainability**
- ✅ Modular design with separate concerns
- ✅ Clear class hierarchy and interfaces
- ✅ Comprehensive docstrings and comments
- ✅ Easily extensible for new operations

### **Portability**
- ✅ Standard Python libraries only
- ✅ Cross-platform compatibility
- ✅ No external dependencies

This implementation provides a robust, maintainable, and efficient arithmetic calculator that meets all specified requirements while adhering to software quality standards.