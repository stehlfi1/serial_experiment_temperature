```python
from typing import List, Union

class Calculator:
    """
    A high-quality, maintainable calculator to evaluate arithmetic expressions.
    Supports +, -, *, /, parentheses, integers, floats, and negative values.

    This implementation ensures:
        - Correct operator precedence and associativity,
        - Input validation (invalid characters, unbalanced parentheses, division by zero),
        - Modularity and clarity.
    """

    # Supported operators and their precedence & associativity (L=left, R=right)
    _OPERATORS = {
        '+': {'precedence': 1, 'associativity': 'L', 'function': lambda a, b: a + b},
        '-': {'precedence': 1, 'associativity': 'L', 'function': lambda a, b: a - b},
        '*': {'precedence': 2, 'associativity': 'L', 'function': lambda a, b: a * b},
        '/': {'precedence': 2, 'associativity': 'L', 'function': lambda a, b: a / b},
    }
    _VALID_CHARS = set('0123456789.+-*/() ')

    def calculate(self, expression: str) -> float:
        """
        Evaluates the arithmetic expression and returns the result as a float.

        :param expression: The arithmetic expression to evaluate.
        :return: The result of the evaluation as a float.
        :raises ValueError: For invalid syntax or input.
        :raises ZeroDivisionError: On division by zero during evaluation.
        """
        tokens = self._tokenize(expression)
        rpn = self._infix_to_rpn(tokens)
        result = self._evaluate_rpn(rpn)
        return result

    def _validate_characters(self, expression: str) -> None:
        """Validate that the expression contains only valid characters."""
        for ch in expression:
            if ch not in self._VALID_CHARS:
                raise ValueError(f"Invalid character detected: '{ch}'")

    def _tokenize(self, expression: str) -> List[Union[str, float]]:
        """
        Convert the input expression into tokens (numbers, operators, parentheses),
        handling negative numbers and input validation.

        :param expression: The input expression string.
        :return: List of tokens.
        :raises ValueError: For invalid input.
        """
        self._validate_characters(expression)
        tokens = []
        num_buffer = ''
        i = 0
        length = len(expression)
        prev_token = None  # Keeps track of previous token type

        while i < length:
            ch = expression[i]

            if ch.isspace():
                i += 1
                continue

            if ch in '0123456789.':
                num_buffer += ch
                i += 1
                prev_token = 'number'
            elif ch in '+-':
                # Determine unary minus/plus
                if (prev_token in (None, '(', 'operator')) or (prev_token is None and ch == '-'):
                    # Look ahead for the number
                    sign = 1 if ch == '+' else -1
                    i += 1
                    num_part = ''
                    while i < length and (expression[i].isdigit() or expression[i] == '.'):
                        num_part += expression[i]
                        i += 1
                    if not num_part:
                        raise ValueError("Invalid use of sign operator.")
                    try:
                        number = sign * float(num_part)
                    except ValueError:
                        raise ValueError(
                            f"Invalid number format after {ch}: '{num_part}'"
                        )
                    tokens.append(number)
                    prev_token = 'number'
                else:
                    # Operator
                    if num_buffer:
                        tokens.append(float(num_buffer))
                        num_buffer = ''
                    tokens.append(ch)
                    i += 1
                    prev_token = 'operator'
            elif ch in '*/':
                if num_buffer:
                    tokens.append(float(num_buffer))
                    num_buffer = ''
                tokens.append(ch)
                i += 1
                prev_token = 'operator'
            elif ch == '(':
                if num_buffer:
                    tokens.append(float(num_buffer))
                    num_buffer = ''
                tokens.append(ch)
                i += 1
                prev_token = '('
            elif ch == ')':
                if num_buffer:
                    tokens.append(float(num_buffer))
                    num_buffer = ''
                tokens.append(ch)
                i += 1
                prev_token = ')'
            else:
                raise ValueError(f"Invalid character detected: '{ch}'")

        if num_buffer:
            tokens.append(float(num_buffer))

        # Final validation for empty expressions
        if not tokens:
            raise ValueError("Empty expression.")

        # Check for balanced parentheses
        self._check_balanced_parentheses(tokens)

        return tokens

    def _check_balanced_parentheses(self, tokens: List[Union[str, float]]) -> None:
        """Check that parentheses in tokens are balanced."""
        count = 0
        for token in tokens:
            if token == '(':
                count += 1
            elif token == ')':
                count -= 1
                if count < 0:
                    raise ValueError("Unbalanced parentheses: closing parenthesis without opening.")
        if count != 0:
            raise ValueError("Unbalanced parentheses: missing closing parenthesis.")

    def _infix_to_rpn(self, tokens: List[Union[str, float]]) -> List[Union[str, float]]:
        """
        Convert infix tokens to Reverse Polish Notation using the shunting yard algorithm.

        :param tokens: List of tokens in infix order.
        :return: List of tokens in RPN.
        :raises ValueError: For invalid expressions.
        """
        output = []
        stack = []
        for token in tokens:
            if isinstance(token, float):
                output.append(token)
            elif token in self._OPERATORS:
                while stack and stack[-1] in self._OPERATORS:
                    op1 = token
                    op2 = stack[-1]
                    p1 = self._OPERATORS[op1]['precedence']
                    p2 = self._OPERATORS[op2]['precedence']
                    assoc = self._OPERATORS[op1]['associativity']
                    if (assoc == 'L' and p1 <= p2) or (assoc == 'R' and p1 < p2):
                        output.append(stack.pop())
                    else:
                        break
                stack.append(token)
            elif token == '(':
                stack.append(token)
            elif token == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                if not stack or stack[-1] != '(':
                    raise ValueError("Mismatched parentheses.")
                stack.pop()  # Pop '('
            else:
                raise ValueError(f"Unknown token: {token}")

        while stack:
            if stack[-1] in ('(', ')'):
                raise ValueError("Mismatched parentheses.")
            output.append(stack.pop())
        return output

    def _evaluate_rpn(self, tokens: List[Union[str, float]]) -> float:
        """
        Evaluate a Reverse Polish Notation (postfix) expression.

        :param tokens: List of RPN tokens.
        :return: Computed float result.
        :raises ZeroDivisionError: On division by zero.
        :raises ValueError: For malformed expressions.
        """
        stack = []
        for token in tokens:
            if isinstance(token, float):
                stack.append(token)
            elif token in self._OPERATORS:
                # Binary operator, pop two operands
                if len(stack) < 2:
                    raise ValueError("Malformed expression: insufficient operands.")
                b = stack.pop()
                a = stack.pop()
                if token == '/' and b == 0:
                    raise ZeroDivisionError("Division by zero.")
                result = self._OPERATORS[token]['function'](a, b)
                stack.append(result)
            else:
                raise ValueError(f"Unknown token in evaluation: {token}")
        if len(stack) != 1:
            raise ValueError("Malformed expression: elements remain after evaluation.")
        return stack[0]


if __name__ == '__main__':
    # Example usage and test cases
    calculator = Calculator()

    expressions = [
        "1 + 2 * 3",
        "(1 + 2) * 3",
        " 3 + 4 * 2 / ( 1 - 5 ) ",
        "-2 + (5.2 * -3) / (7.7 - 3)",
        "5 / 0",  # Division by zero
        "2 + (3 * (4 - 1)",  # Unbalanced
        "abc + 1",  # Invalid characters
        "4 + ++2",  # Invalid syntax
        "4.5 * -.3",
        "",
    ]

    for expr in expressions:
        print(f"Expression: {expr}")
        try:
            result = calculator.calculate(expr)
            print(f"Result: {result}")
        except Exception as e:
            print(f"Error: {e}")
        print('-' * 40)
```
**Key Features:**
- **No use of `eval`**; all parsing and evaluation is internal and safe.
- **Operator precedence** and **parentheses** respected.
- **Unambiguous handling of negative numbers**.
- **Input validation** for unexpected characters and syntax errors.
- **Clear modular structure** for maintainability and testing.
- **Comprehensive docstrings** and comments.

You can remove or expand the `__main__` section as necessary for extensive unit tests.