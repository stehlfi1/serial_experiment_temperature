Of course. As a senior software developer, I will provide a high-quality implementation of a console-based calculator that adheres to the specified requirements and the principles of the ISO/IEC 25010 standard.

The chosen algorithm is a direct evaluation approach using two stacksâ€”one for numbers (operands) and one for operators. This is a standard, efficient, and robust method for parsing and evaluating arithmetic expressions without using `eval()`, which is a critical security and safety requirement.

Here is the complete, well-documented, and testable Python code.

```python
"""
A high-quality, console-based arithmetic calculator.

This module provides a `Calculator` class that can parse and evaluate
mathematical expressions from a string, adhering to standard operator precedence.
The implementation follows best practices and aligns with the principles of the
ISO/IEC 25010 standard for software quality.

ISO/IEC 25010 Characteristics Met:
----------------------------------
- Functional Suitability (Correctness, Completeness):
  - The calculator correctly evaluates expressions with +, -, *, /, parentheses,
    and proper operator precedence. It supports integers, floats, and negative numbers.

- Performance Efficiency (Time Behaviour):
  - The implementation uses a single-pass, two-stack algorithm which has a time
    complexity of O(n), where n is the length of the expression. This is efficient
    for typical use cases.

- Maintainability (Modularity, Reusability, Analysability, Modifiability):
  - The logic is encapsulated within the `Calculator` class.
  - Helper methods (`_tokenize`, `_apply_op`, `_precedence`) break down the
    problem into smaller, manageable, and testable parts.
  - The code is well-documented with docstrings and comments, making it easy to
    understand and modify.

- Reliability (Maturity, Fault Tolerance):
  - The code is protected against invalid inputs through comprehensive validation.
  - It raises specific, built-in error types (`ValueError`, `ZeroDivisionError`)
    for different failure modes, such as malformed expressions, invalid characters,
    unbalanced parentheses, and division by zero.

- Security (Confidentiality, Integrity, Non-repudiation, Accountability, Authenticity):
  - By explicitly avoiding `eval()` and its equivalents, the code is protected
    from code injection vulnerabilities, a critical security consideration.

- Usability (Learnability, Operability):
  - The public interface `calculate(expression)` is simple and intuitive.
  - The console-based example demonstrates clear, user-friendly interaction.

- Portability (Adaptability, Installability):
  - The code uses only Python's standard library, ensuring it can run on any
    platform with a Python interpreter without external dependencies.
"""

import operator
from typing import Generator, Union


class Calculator:
    """
    A class to evaluate arithmetic expressions from a string.

    This calculator supports addition, subtraction, multiplication, division,
    and parentheses. It correctly handles operator precedence and can process
    integer and floating-point numbers, including negative values.
    """

    # Define supported operators and their precedence
    _OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}
    _PRECEDENCE = {'+': 1, '-': 1, '*': 2, '/': 2}

    def _apply_op(self, op: str, b: float, a: float) -> float:
        """
        Applies an operator to two operands.

        Args:
            op: The operator character (+, -, *, /).
            b: The second operand.
            a: The first operand.

        Returns:
            The result of the operation.

        Raises:
            ZeroDivisionError: If the operator is '/' and the second operand is 0.
        """
        if op == '/' and b == 0:
            raise ZeroDivisionError("Division by zero is not allowed.")
        return self._OPERATORS[op](a, b)

    def _tokenize(self, expression: str) -> Generator[str, None, None]:
        """
        Converts an expression string into a stream of tokens.

        This tokenizer correctly handles multi-digit numbers, floating-point numbers,
        and unary minus (negative numbers), distinguishing it from binary subtraction.

        Args:
            expression: The string expression to tokenize.

        Yields:
            Tokens (numbers, operators, parentheses) as strings.

        Raises:
            ValueError: If an invalid character is found in the expression.
        """
        # Remove all whitespace for easier parsing
        expression = expression.replace(" ", "")
        
        allowed_chars = "0123456789.+-*/()"
        for char in expression:
            if char not in allowed_chars:
                raise ValueError(f"Invalid character '{char}' in expression.")

        i = 0
        is_unary_minus_possible = True
        while i < len(expression):
            char = expression[i]

            if char.isdigit() or (char == '.'):
                # Parse a full number (integer or float)
                num_str = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num_str += expression[i]
                    i += 1
                yield num_str
                is_unary_minus_possible = False
                continue

            if char in self._OPERATORS:
                # Handle unary minus vs. binary subtraction
                if char == '-' and is_unary_minus_possible:
                    # This is a unary minus, part of a negative number
                    i += 1
                    num_str = "-"
                    while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                        num_str += expression[i]
                        i += 1
                    if num_str == "-":
                        raise ValueError("Invalid expression: hanging minus sign.")
                    yield num_str
                    is_unary_minus_possible = False
                else:
                    # This is a binary operator
                    yield char
                    is_unary_minus_possible = True
            elif char == '(':
                yield char
                is_unary_minus_possible = True
            elif char == ')':
                yield char
                is_unary_minus_possible = False
            i += 1

    def calculate(self, expression: str) -> float:
        """
        Evaluates a given arithmetic expression string.

        This is the main public method that orchestrates the tokenization and
        evaluation of the expression using a two-stack algorithm.

        Args:
            expression: The arithmetic expression string to evaluate.

        Returns:
            The result of the evaluation as a float.

        Raises:
            ValueError: For malformed expressions, such as unbalanced parentheses
                        or invalid operator sequences.
            ZeroDivisionError: For division by zero.
        """
        if not isinstance(expression, str):
            raise TypeError("Expression must be a string.")
        if not expression.strip():
            raise ValueError("Expression cannot be empty.")

        values: list[float] = []  # Stack for numbers
        ops: list[str] = []       # Stack for operators and parentheses

        def process_ops_stack(precedence_level: int = 0):
            """Helper to process operators from the stack based on precedence."""
            while ops and ops[-1] != '(' and self._PRECEDENCE.get(ops[-1], 0) >= precedence_level:
                try:
                    op = ops.pop()
                    val2 = values.pop()
                    val1 = values.pop()
                    values.append(self._apply_op(op, val2, val1))
                except IndexError:
                    raise ValueError("Malformed expression: Invalid operator sequence or missing operand.")

        for token in self._tokenize(expression):
            try:
                # If the token is a number, push it to the values stack
                values.append(float(token))
            except ValueError:
                # The token is not a number, it must be an operator or parenthesis
                if token == '(':
                    ops.append(token)
                elif token == ')':
                    # Process all operations until an opening parenthesis is found
                    process_ops_stack()
                    if not ops or ops.pop() != '(':
                        raise ValueError("Malformed expression: Unbalanced parentheses.")
                elif token in self._OPERATORS:
                    # Process operators with higher or equal precedence first
                    process_ops_stack(self._PRECEDENCE[token])
                    ops.append(token)
                else:
                    # This case should not be reached due to tokenizer validation
                    raise ValueError(f"Unknown token: {token}")

        # Process any remaining operators on the stack
        process_ops_stack()

        if '(' in ops:
            raise ValueError("Malformed expression: Unbalanced parentheses.")
        if len(values) != 1 or ops:
            raise ValueError("Malformed expression: Incomplete or invalid.")

        return values[0]


if __name__ == "__main__":
    """
    An interactive console to demonstrate the Calculator's functionality.
    This section serves as a simple, runnable example and manual test harness.
    """
    print("--- High-Quality Python Calculator ---")
    print("Enter an arithmetic expression to evaluate or 'exit' to quit.")
    print("Examples: 3.5 + 4 * (2 - 1) / 2, -5 * (3 + 2), 100 / -4")
    print("-" * 35)

    calculator = Calculator()

    while True:
        try:
            user_input = input(">>> ")
            if user_input.lower() == 'exit':
                print("Exiting calculator.")
                break
            
            result = calculator.calculate(user_input)
            # Format output to be clean, showing integer if result is whole
            if result == int(result):
                print(f"= {int(result)}")
            else:
                print(f"= {result:.4f}")

        except (ValueError, ZeroDivisionError, TypeError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nExiting calculator.")
            break
        except Exception as e:
            print(f"An unexpected error occurred: {e}")

```