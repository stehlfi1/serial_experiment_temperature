```python
import re
from typing import List, Union

class Calculator:
    """
    A console-based arithmetic calculator that evaluates mathematical expressions
    containing +, -, *, /, parentheses, integers, floating-point numbers, and negative values.

    Adheres to ISO/IEC 25010 quality requirements:
        - Correctness: Correctly parses and evaluates arithmetic expressions.
        - Performance: Uses the Shunting Yard Algorithm for efficient evaluation.
        - Modularity: Separates tokenization, parsing, and evaluation logic.
        - Safety: Rejects invalid inputs and raises appropriate errors.
        - Testability: Easily testable by passing string expressions.
        - Readability/Documentation: Well-documented and clear code.
    """

    def calculate(self, expression: str) -> float:
        """
        Evaluates the given arithmetic expression and returns the result as a float.

        :param expression: A string representing the arithmetic expression.
        :return: The evaluated result as a float.
        :raises ValueError: If the input is invalid or contains unsupported characters.
        :raises ZeroDivisionError: If division by zero occurs.
        """
        tokens = self._tokenize(expression)
        rpn = self._to_rpn(tokens)
        result = self._evaluate_rpn(rpn)
        return result

    # ------------------------ Internal Implementation ------------------------

    # Operator precedence and associativity
    _OPERATORS = {
        '+': (1, 'L'),
        '-': (1, 'L'),
        '*': (2, 'L'),
        '/': (2, 'L')
    }

    def _tokenize(self, expression: str) -> List[str]:
        """
        Converts the input string into a list of tokens (numbers, operators, parentheses).
        Handles negative numbers and validates allowed characters.

        :param expression: Input string.
        :return: List of tokens.
        :raises ValueError: For invalid characters or unbalanced parentheses.
        """
        # Remove whitespace for easier processing
        expr = expression.replace(' ', '')

        # Allowed characters: digits, decimal point, operators, parentheses
        if not re.fullmatch(r'[-+*/().\d]+', expr):
            raise ValueError("Expression contains invalid characters.")

        tokens = []
        i = 0
        n = len(expr)
        paren_count = 0

        while i < n:
            char = expr[i]

            # Number (integer or float), possibly negative
            if char.isdigit() or (char == '.' and i+1 < n and expr[i+1].isdigit()):
                num_match = re.match(r'\d+(\.\d*)?|\.\d+', expr[i:])
                if not num_match:
                    raise ValueError("Invalid number format.")
                num_str = num_match.group(0)
                tokens.append(num_str)
                i += len(num_str)

            # Parentheses
            elif char == '(':
                tokens.append(char)
                paren_count += 1
                i += 1
            elif char == ')':
                tokens.append(char)
                paren_count -= 1
                if paren_count < 0:
                    raise ValueError("Unbalanced parentheses.")
                i += 1

            # Operator
            elif char in self._OPERATORS:
                # Handle negative numbers (unary minus)
                if char == '-' and (
                    i == 0 or expr[i-1] in '(-+*/'
                ):
                    # Look ahead for the number
                    j = i + 1
                    if j < n and (expr[j].isdigit() or expr[j] == '.'):
                        num_match = re.match(r'-\d+(\.\d*)?|-?\.\d+', expr[i:])
                        if not num_match:
                            raise ValueError("Invalid negative number format.")
                        num_str = num_match.group(0)
                        tokens.append(num_str)
                        i += len(num_str)
                    else:
                        raise ValueError("Invalid usage of '-' operator.")
                else:
                    tokens.append(char)
                    i += 1
            else:
                raise ValueError(f"Unexpected character '{char}' in expression.")

        if paren_count != 0:
            raise ValueError("Unbalanced parentheses.")

        return tokens

    def _to_rpn(self, tokens: List[str]) -> List[str]:
        """
        Converts the token list to Reverse Polish Notation (RPN) using the Shunting Yard algorithm.

        :param tokens: List of tokens.
        :return: RPN as a list of tokens.
        :raises ValueError: For mismatched parentheses or invalid syntax.
        """
        output = []
        stack = []

        for token in tokens:
            if self._is_number(token):
                output.append(token)
            elif token in self._OPERATORS:
                while stack and stack[-1] in self._OPERATORS:
                    top_op = stack[-1]
                    curr_prec, curr_assoc = self._OPERATORS[token]
                    top_prec, _ = self._OPERATORS[top_op]
                    if (curr_assoc == 'L' and curr_prec <= top_prec) or \
                       (curr_assoc == 'R' and curr_prec < top_prec):
                        output.append(stack.pop())
                    else:
                        break
                stack.append(token)
            elif token == '(':
                stack.append(token)
            elif token == ')':
                while stack and stack[-1] != '(':
                    output.append(stack.pop())
                if not stack:
                    raise ValueError("Mismatched parentheses.")
                stack.pop()  # Remove '('
            else:
                raise ValueError(f"Invalid token '{token}' in expression.")

        while stack:
            if stack[-1] in '()':
                raise ValueError("Mismatched parentheses.")
            output.append(stack.pop())

        return output

    def _evaluate_rpn(self, rpn: List[str]) -> float:
        """
        Evaluates a Reverse Polish Notation (RPN) expression.

        :param rpn: List of tokens in RPN.
        :return: Evaluated result as float.
        :raises ZeroDivisionError: On division by zero.
        :raises ValueError: On invalid syntax or insufficient operands.
        """
        stack: List[float] = []

        for token in rpn:
            if self._is_number(token):
                stack.append(float(token))
            elif token in self._OPERATORS:
                if len(stack) < 2:
                    raise ValueError("Insufficient operands for operation.")
                b = stack.pop()
                a = stack.pop()
                result = self._apply_operator(a, b, token)
                stack.append(result)
            else:
                raise ValueError(f"Invalid token '{token}' in evaluation.")

        if len(stack) != 1:
            raise ValueError("Invalid expression: Too many operands.")

        return stack[0]

    @staticmethod
    def _is_number(token: str) -> bool:
        """
        Checks if the token is a valid number (integer or float).

        :param token: String token.
        :return: True if token is a number, False otherwise.
        """
        return re.fullmatch(r'-?\d+(\.\d*)?|-?\.\d+', token) is not None

    @staticmethod
    def _apply_operator(a: float, b: float, op: str) -> float:
        """
        Applies the given operator to two operands.

        :param a: Left operand.
        :param b: Right operand.
        :param op: Operator as string.
        :return: Result of the operation.
        :raises ZeroDivisionError: On division by zero.
        """
        if op == '+':
            return a + b
        elif op == '-':
            return a - b
        elif op == '*':
            return a * b
        elif op == '/':
            if b == 0:
                raise ZeroDivisionError("Division by zero.")
            return a / b
        else:
            raise ValueError(f"Unsupported operator '{op}'.")

# ------------------------ Example Usage & Testing ------------------------

if __name__ == "__main__":
    calc = Calculator()

    test_expressions = [
        "1 + 2 * 3",              # 7
        "(1 + 2) * 3",            # 9
        "-4 + 3 * (2.5 - 1)",     # -4 + 3*1.5 = 0.5
        "-3.5 + (2)",             # -1.5
        "3 + 4 * 2 / (1 - 5)",    # 3 + 8 / -4 = 3 - 2 = 1
        "5 / 0",                  # Should raise ZeroDivisionError
        "((2+3)*(-2.5))",         # -12.5
        "1.2.3 + 4",              # Should raise ValueError (invalid number)
        "((1+2)",                 # Should raise ValueError (unbalanced parens)
        "2 + a",                  # Should raise ValueError (invalid character)
        "--2 + 2",                # Should raise ValueError (invalid double minus)
        "4 + (-5)",               # -1
        "-(3 + 2)",               # Should raise ValueError (unsupported unary minus before paren)
    ]

    for expr in test_expressions:
        try:
            result = calc.calculate(expr)
            print(f"{expr} = {result}")
        except Exception as e:
            print(f"{expr} -> Error: {e}")
```
