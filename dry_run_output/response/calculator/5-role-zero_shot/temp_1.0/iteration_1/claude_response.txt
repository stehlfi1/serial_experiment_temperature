```python
"""
A comprehensive arithmetic calculator implementation following ISO/IEC 25010 standards.

This module provides a Calculator class that can evaluate mathematical expressions
with proper operator precedence, parentheses support, and comprehensive error handling.
"""

import re
from typing import List, Union, Tuple
from enum import Enum


class TokenType(Enum):
    """Enumeration for different types of tokens in mathematical expressions."""
    NUMBER = "NUMBER"
    OPERATOR = "OPERATOR"
    LEFT_PAREN = "LEFT_PAREN"
    RIGHT_PAREN = "RIGHT_PAREN"


class Token:
    """Represents a single token in a mathematical expression."""
    
    def __init__(self, token_type: TokenType, value: Union[float, str]):
        """
        Initialize a token.
        
        Args:
            token_type: The type of the token
            value: The value of the token (number or operator symbol)
        """
        self.type = token_type
        self.value = value
    
    def __repr__(self) -> str:
        return f"Token({self.type}, {self.value})"


class Calculator:
    """
    A calculator class that evaluates arithmetic expressions using the Shunting Yard algorithm.
    
    Supports basic arithmetic operations (+, -, *, /) with proper precedence,
    parentheses, and both integer and floating-point numbers.
    """
    
    # Operator precedence mapping (higher value = higher precedence)
    OPERATOR_PRECEDENCE = {'+': 1, '-': 1, '*': 2, '/': 2}
    
    # Valid operators
    VALID_OPERATORS = {'+', '-', '*', '/'}
    
    def __init__(self):
        """Initialize the calculator."""
        pass
    
    def calculate(self, expression: str) -> float:
        """
        Evaluate a mathematical expression and return the result.
        
        Args:
            expression: A string containing the mathematical expression to evaluate
            
        Returns:
            The numerical result of the expression as a float
            
        Raises:
            ValueError: If the expression contains invalid characters, 
                       unbalanced parentheses, or invalid syntax
            ZeroDivisionError: If division by zero is attempted
            
        Examples:
            >>> calc = Calculator()
            >>> calc.calculate("2 + 3 * 4")
            14.0
            >>> calc.calculate("(2 + 3) * 4")
            20.0
            >>> calc.calculate("-5.5 + 2.3")
            -3.2
        """
        if not expression or not expression.strip():
            raise ValueError("Expression cannot be empty")
        
        # Remove whitespace and validate basic structure
        expression = expression.replace(" ", "")
        self._validate_expression(expression)
        
        # Tokenize the expression
        tokens = self._tokenize(expression)
        
        # Convert to postfix notation using Shunting Yard algorithm
        postfix = self._infix_to_postfix(tokens)
        
        # Evaluate the postfix expression
        return self._evaluate_postfix(postfix)
    
    def _validate_expression(self, expression: str) -> None:
        """
        Validate the basic structure of the expression.
        
        Args:
            expression: The expression to validate
            
        Raises:
            ValueError: If the expression contains invalid characters or structure
        """
        # Check for valid characters only
        valid_chars = set('0123456789+-*/.() ')
        if not all(char in valid_chars for char in expression):
            raise ValueError("Expression contains invalid characters")
        
        # Check for balanced parentheses
        paren_count = 0
        for char in expression:
            if char == '(':
                paren_count += 1
            elif char == ')':
                paren_count -= 1
                if paren_count < 0:
                    raise ValueError("Unbalanced parentheses: too many closing parentheses")
        
        if paren_count != 0:
            raise ValueError("Unbalanced parentheses: missing closing parentheses")
        
        # Check for empty parentheses
        if "()" in expression:
            raise ValueError("Empty parentheses are not allowed")
    
    def _tokenize(self, expression: str) -> List[Token]:
        """
        Convert the expression string into a list of tokens.
        
        Args:
            expression: The expression to tokenize
            
        Returns:
            A list of Token objects
            
        Raises:
            ValueError: If the expression has invalid syntax
        """
        tokens = []
        i = 0
        
        while i < len(expression):
            char = expression[i]
            
            # Handle numbers (including negative numbers and decimals)
            if char.isdigit() or char == '.':
                number_str, i = self._extract_number(expression, i)
                tokens.append(Token(TokenType.NUMBER, float(number_str)))
            
            # Handle operators
            elif char in self.VALID_OPERATORS:
                # Handle negative numbers (unary minus)
                if char == '-' and self._is_unary_minus(tokens):
                    # This is a unary minus, combine with the next number
                    i += 1
                    if i >= len(expression) or not (expression[i].isdigit() or expression[i] == '.'):
                        raise ValueError("Invalid expression: operator without operand")
                    number_str, i = self._extract_number(expression, i)
                    tokens.append(Token(TokenType.NUMBER, -float(number_str)))
                else:
                    tokens.append(Token(TokenType.OPERATOR, char))
                    i += 1
            
            # Handle parentheses
            elif char == '(':
                tokens.append(Token(TokenType.LEFT_PAREN, char))
                i += 1
            elif char == ')':
                tokens.append(Token(TokenType.RIGHT_PAREN, char))
                i += 1
            
            else:
                i += 1  # Skip whitespace or other characters
        
        self._validate_token_sequence(tokens)
        return tokens
    
    def _extract_number(self, expression: str, start_index: int) -> Tuple[str, int]:
        """
        Extract a complete number (including decimals) from the expression.
        
        Args:
            expression: The full expression
            start_index: The starting index of the number
            
        Returns:
            A tuple of (number_string, next_index)
            
        Raises:
            ValueError: If the number format is invalid
        """
        i = start_index
        number_str = ""
        decimal_count = 0
        
        while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
            if expression[i] == '.':
                decimal_count += 1
                if decimal_count > 1:
                    raise ValueError("Invalid number format: multiple decimal points")
            number_str += expression[i]
            i += 1
        
        if not number_str or number_str == '.':
            raise ValueError("Invalid number format")
        
        return number_str, i
    
    def _is_unary_minus(self, tokens: List[Token]) -> bool:
        """
        Determine if a minus sign should be treated as unary (negative sign).
        
        Args:
            tokens: The current list of tokens
            
        Returns:
            True if the minus should be treated as unary, False otherwise
        """
        if not tokens:
            return True
        
        last_token = tokens[-1]
        return (last_token.type == TokenType.OPERATOR or 
                last_token.type == TokenType.LEFT_PAREN)
    
    def _validate_token_sequence(self, tokens: List[Token]) -> None:
        """
        Validate that the sequence of tokens represents a valid expression.
        
        Args:
            tokens: The list of tokens to validate
            
        Raises:
            ValueError: If the token sequence is invalid
        """
        if not tokens:
            raise ValueError("Expression cannot be empty")
        
        # Check for consecutive operators or numbers
        for i in range(len(tokens) - 1):
            current = tokens[i]
            next_token = tokens[i + 1]
            
            # Two consecutive operators (except unary minus handling)
            if (current.type == TokenType.OPERATOR and 
                next_token.type == TokenType.OPERATOR):
                raise ValueError("Invalid expression: consecutive operators")
            
            # Two consecutive numbers
            if (current.type == TokenType.NUMBER and 
                next_token.type == TokenType.NUMBER):
                raise ValueError("Invalid expression: consecutive numbers")
            
            # Operator followed by closing parenthesis
            if (current.type == TokenType.OPERATOR and 
                next_token.type == TokenType.RIGHT_PAREN):
                raise ValueError("Invalid expression: operator before closing parenthesis")
        
        # Expression cannot start with binary operator (except unary minus)
        first_token = tokens[0]
        if first_token.type == TokenType.OPERATOR and first_token.value in {'*', '/', '+'}:
            raise ValueError("Expression cannot start with a binary operator")
        
        # Expression cannot end with operator or opening parenthesis
        last_token = tokens[-1]
        if (last_token.type == TokenType.OPERATOR or 
            last_token.type == TokenType.LEFT_PAREN):
            raise ValueError("Expression cannot end with an operator or opening parenthesis")
    
    def _infix_to_postfix(self, tokens: List[Token]) -> List[Token]:
        """
        Convert infix notation to postfix notation using the Shunting Yard algorithm.
        
        Args:
            tokens: List of tokens in infix notation
            
        Returns:
            List of tokens in postfix notation
        """
        output_queue = []
        operator_stack = []
        
        for token in tokens:
            if token.type == TokenType.NUMBER:
                output_queue.append(token)
            
            elif token.type == TokenType.OPERATOR:
                # Pop operators with higher or equal precedence
                while (operator_stack and 
                       operator_stack[-1].type == TokenType.OPERATOR and
                       self.OPERATOR_PRECEDENCE[operator_stack[-1].value] >= 
                       self.OPERATOR_PRECEDENCE[token.value]):
                    output_queue.append(operator_stack.pop())
                
                operator_stack.append(token)
            
            elif token.type == TokenType.LEFT_PAREN:
                operator_stack.append(token)
            
            elif token.type == TokenType.RIGHT_PAREN:
                # Pop until we find the matching left parenthesis
                while (operator_stack and 
                       operator_stack[-1].type != TokenType.LEFT_PAREN):
                    output_queue.append(operator_stack.pop())
                
                # Remove the left parenthesis
                if operator_stack:
                    operator_stack.pop()
        
        # Pop any remaining operators
        while operator_stack:
            output_queue.append(operator_stack.pop())
        
        return output_queue
    
    def _evaluate_postfix(self, postfix_tokens: List[Token]) -> float:
        """
        Evaluate a postfix expression and return the result.
        
        Args:
            postfix_tokens: List of tokens in postfix notation
            
        Returns:
            The numerical result of the expression
            
        Raises:
            ZeroDivisionError: If division by zero is attempted
            ValueError: If the expression is malformed
        """
        stack = []
        
        for token in postfix_tokens:
            if token.type == TokenType.NUMBER:
                stack.append(token.value)
            
            elif token.type == TokenType.OPERATOR:
                if len(stack) < 2:
                    raise ValueError("Invalid expression: insufficient operands")
                
                # Pop two operands (note the order)
                right_operand = stack.pop()
                left_operand = stack.pop()
                
                # Perform the operation
                result = self._perform_operation(left_operand, right_operand, token.value)
                stack.append(result)
        
        if len(stack) != 1:
            raise ValueError("Invalid expression: malformed syntax")
        
        return stack[0]
    
    def _perform_operation(self, left: float, right: float, operator: str) -> float:
        """
        Perform a single arithmetic operation.
        
        Args:
            left: Left operand
            right: Right operand
            operator: The operator symbol
            
        Returns:
            The result of the operation
            
        Raises:
            ZeroDivisionError: If division by zero is attempted
            ValueError: If the operator is invalid
        """
        if operator == '+':
            return left + right
        elif operator == '-':
            return left - right
        elif operator == '*':
            return left * right
        elif operator == '/':
            if right == 0:
                raise ZeroDivisionError("Division by zero")
            return left / right
        else:
            raise ValueError(f"Invalid operator: {operator}")


def main():
    """
    Main function to demonstrate the calculator with interactive console interface.
    """
    calculator = Calculator()
    
    print("=== Arithmetic Calculator ===")
    print("Supports: +, -, *, /, parentheses, and decimal numbers")
    print("Type 'quit' or 'exit' to stop")
    print()
    
    while True:
        try:
            expression = input("Enter expression: ").strip()
            
            if expression.lower() in ('quit', 'exit'):
                print("Goodbye!")
                break
            
            if not expression:
                continue
            
            result = calculator.calculate(expression)
            print(f"Result: {result}")
            
        except (ValueError, ZeroDivisionError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")
        
        print()


if __name__ == "__main__":
    main()
```

This implementation follows the ISO/IEC 25010 standard and incorporates all the requested requirements:

## Key Features:

**Functionality Requirements:**
- ✅ Basic arithmetic operations (+, -, *, /)
- ✅ Parentheses support with proper precedence
- ✅ Integer and floating-point number support
- ✅ Negative number support

**Implementation Requirements:**
- ✅ Object-oriented design with Calculator class
- ✅ `calculate(expression: str) -> float` interface
- ✅ Comprehensive validation with built-in error types
- ✅ No use of `eval()` - implements Shunting Yard algorithm
- ✅ Proper error handling for all edge cases

**Code Quality (ISO/IEC 25010):**

1. **Functional Suitability:** Correctly implements all required mathematical operations
2. **Performance Efficiency:** Uses efficient Shunting Yard algorithm (O(n) time complexity)
3. **Compatibility:** Pure Python with no external dependencies
4. **Usability:** Clear error messages and intuitive interface
5. **Reliability:** Comprehensive error handling and input validation
6. **Security:** Protection against malicious input and edge cases
7. **Maintainability:** Clean separation of concerns, extensive documentation
8. **Portability:** Standard Python code that runs anywhere

## Algorithm Details:

The implementation uses the **Shunting Yard algorithm** for expression parsing, which:
- Converts infix notation to postfix notation
- Handles operator precedence automatically
- Supports parentheses grouping
- Provides efficient O(n) time complexity

## Error Handling:

- Invalid characters
- Unbalanced parentheses
- Division by zero
- Empty expressions
- Consecutive operators/numbers
- Invalid number formats
- Malformed expressions

The code is highly testable, well-documented, and follows Python best practices while maintaining excellent performance and reliability.