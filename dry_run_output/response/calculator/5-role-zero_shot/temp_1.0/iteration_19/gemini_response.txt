Of course. Here is a high-quality, production-ready implementation of a console-based calculator in Python. The solution adheres to the specified requirements, including object-oriented design, ISO/IEC 25010 quality characteristics, and avoidance of the `eval()` function.

The core of this solution uses a two-step process, which is a standard and robust way to parse and evaluate mathematical expressions:
1.  **Shunting-yard Algorithm:** The infix expression (e.g., `3 + 4 * 2`) is converted into a postfix expression, also known as Reverse Polish Notation (RPN) (e.g., `3 4 2 * +`). This conversion correctly handles operator precedence and parentheses.
2.  **RPN Evaluation:** The postfix expression is evaluated efficiently using a stack.

This approach ensures correctness, is performant, and its modular structure makes it highly maintainable and testable.

```python
"""
A high-quality, console-based arithmetic calculator in Python.

This module provides a `Calculator` class that can parse and evaluate
mathematical expressions, adhering to ISO/IEC 25010 software quality standards.
"""

import re
import operator
from typing import List, Union

# Define a new type for clarity in type hints
Numeric = Union[int, float]


class Calculator:
    """
    A robust calculator for evaluating arithmetic expressions from strings.

    This class provides a safe and efficient way to compute expressions
    containing integers, floating-point numbers, parentheses, and standard
    arithmetic operators. It does not use the built-in `eval()` function,
    making it secure against code injection.

    The implementation follows best practices for software quality, focusing on:
    - Correctness: Uses the Shunting-yard algorithm for accurate parsing.
    - Safety: Validates input and handles errors gracefully.
    - Modularity: Separates tokenization, parsing (infix to RPN), and evaluation.
    - Readability: Employs clear variable names, type hints, and docstrings.
    - Performance: Utilizes efficient data structures (lists as stacks/queues).
    - Testability: The public interface and modular design are easy to test.

    Example:
        >>> calculator = Calculator()
        >>> result = calculator.calculate("(3.5 + 4) * 2 / 5 - -1")
        >>> print(result)
        4.0
    """

    def __init__(self):
        """Initializes the Calculator, setting up operator definitions."""
        self._operators = {
            '+': (operator.add, 1),
            '-': (operator.sub, 1),
            '*': (operator.mul, 2),
            '/': (operator.truediv, 2),
        }

    def _tokenize(self, expression: str) -> List[str]:
        """
        Converts the input string expression into a list of tokens.

        This method handles negative numbers and ensures that all characters
        in the expression are valid.

        Args:
            expression: The mathematical expression string.

        Returns:
            A list of tokens (numbers, operators, parentheses).

        Raises:
            ValueError: If the expression contains invalid characters.
        """
        if not isinstance(expression, str) or not expression.strip():
            raise ValueError("Expression must be a non-empty string.")

        # Regex to find numbers (including floating point) and operators
        token_regex = re.compile(r"(\d+\.\d*|\.\d+|\d+|[+\-*/()])")
        tokens = token_regex.findall(expression.replace(" ", ""))

        # Check for invalid characters not captured by the regex
        if "".join(tokens) != expression.replace(" ", ""):
            # Find the first invalid character for a helpful error message
            reconstructed = ""
            original_no_space = expression.replace(" ", "")
            for token in tokens:
                reconstructed += token
                if not original_no_space.startswith(reconstructed):
                    pos = len(reconstructed) - len(token)
                    invalid_char = original_no_space[pos]
                    raise ValueError(f"Invalid character '{invalid_char}' in expression.")
        
        return self._handle_unary_minus(tokens)

    def _handle_unary_minus(self, tokens: List[str]) -> List[str]:
        """
        Processes the token list to correctly handle unary minuses.

        A minus sign is considered unary if it's the first token or if it
        follows an operator or an opening parenthesis.

        Args:
            tokens: The initial list of tokens.

        Returns:
            A new list of tokens with unary minuses combined with their numbers.
        """
        processed_tokens = []
        for i, token in enumerate(tokens):
            if token == '-':
                # Check if it's a unary minus
                is_unary = (i == 0) or (tokens[i-1] in self._operators or tokens[i-1] == '(')
                if is_unary:
                    # Look ahead to the next token, which should be a number
                    if i + 1 < len(tokens) and tokens[i+1].replace('.', '', 1).isdigit():
                        # Prepend the minus to the number token and skip the original minus
                        # This effectively combines '-' and '5' into '-5'
                        continue 
                    else:
                        raise ValueError("Invalid expression: misplaced minus sign.")

                # If it's a binary minus, or part of a unary number that's already processed.
                is_unary_processed = i > 0 and (tokens[i-1] == '-' and ((i-1 == 0) or (tokens[i-2] in self._operators or tokens[i-2] == '(')))
                if is_unary_processed:
                    # This case means the previous token was a unary minus, so we combine them
                    num_token = tokens[i]
                    processed_tokens.append(f"-{num_token}")
                else:
                    processed_tokens.append(token)
            
            # Check if this token was part of a unary operation in the previous step
            elif i > 0 and tokens[i-1] == '-' and ((i-1 == 0) or (tokens[i-2] in self._operators or tokens[i-2] == '(')):
                processed_tokens.append(f"-{token}")
            else:
                processed_tokens.append(token)

        return processed_tokens

    def _to_rpn(self, tokens: List[str]) -> List[Union[str, Numeric]]:
        """
        Converts a list of tokens from infix to Reverse Polish Notation (RPN).

        This method implements the Shunting-yard algorithm.

        Args:
            tokens: A list of tokens from the tokenizer.

        Returns:
            A list of tokens in RPN order.

        Raises:
            ValueError: If the expression has mismatched parentheses.
        """
        output_queue: List[Union[str, Numeric]] = []
        operator_stack: List[str] = []

        for token in tokens:
            try:
                # If the token is a number, add it to the output queue
                output_queue.append(float(token))
            except ValueError:
                if token == '(':
                    operator_stack.append(token)
                elif token == ')':
                    while operator_stack and operator_stack[-1] != '(':
                        output_queue.append(operator_stack.pop())
                    if not operator_stack or operator_stack[-1] != '(':
                        raise ValueError("Mismatched parentheses in expression.")
                    operator_stack.pop()  # Pop the '('
                elif token in self._operators:
                    op1_precedence = self._operators[token][1]
                    while (operator_stack and operator_stack[-1] in self._operators and
                           self._operators[operator_stack[-1]][1] >= op1_precedence):
                        output_queue.append(operator_stack.pop())
                    operator_stack.append(token)
                else:
                    # This case should ideally not be reached due to upstream validation
                    raise ValueError(f"Unknown token: {token}")

        # Pop any remaining operators from the stack to the queue
        while operator_stack:
            op = operator_stack.pop()
            if op == '(':
                raise ValueError("Mismatched parentheses in expression.")
            output_queue.append(op)

        return output_queue

    def _evaluate_rpn(self, rpn_tokens: List[Union[str, Numeric]]) -> Numeric:
        """
        Evaluates an expression in Reverse Polish Notation (RPN).

        Args:
            rpn_tokens: A list of tokens in RPN.

        Returns:
            The final calculated result.

        Raises:
            ValueError: If the expression is malformed.
            ZeroDivisionError: If division by zero is attempted.
        """
        operand_stack: List[Numeric] = []

        for token in rpn_tokens:
            if isinstance(token, (int, float)):
                operand_stack.append(token)
            elif token in self._operators:
                if len(operand_stack) < 2:
                    raise ValueError("Invalid expression: insufficient operands for operator.")
                
                op2 = operand_stack.pop()
                op1 = operand_stack.pop()

                operation, _ = self._operators[token]
                
                if token == '/' and op2 == 0:
                    raise ZeroDivisionError("Division by zero is not allowed.")
                
                result = operation(op1, op2)
                operand_stack.append(result)

        if len(operand_stack) != 1:
            raise ValueError("Invalid expression: too many operands.")

        return operand_stack[0]

    def calculate(self, expression: str) -> float:
        """
        Evaluates a complete mathematical expression string.

        This is the main public method that orchestrates the tokenization,
        parsing, and evaluation of the expression.

        Args:
            expression: The mathematical expression to evaluate.

        Returns:
            The result of the calculation as a float.

        Raises:
            ValueError: For syntax errors, invalid characters, or
                        mismatched parentheses.
            ZeroDivisionError: For division by zero.
        """
        try:
            tokens = self._tokenize(expression)
            rpn_tokens = self._to_rpn(tokens)
            result = self._evaluate_rpn(rpn_tokens)
            return float(result)
        except (ValueError, ZeroDivisionError) as e:
            # Re-raise exceptions with a clear prefix for better context
            raise type(e)(f"Calculation Error: {e}") from e
        except Exception as e:
            # Catch any other unexpected errors for robustness
            raise RuntimeError(f"An unexpected error occurred: {e}") from e

if __name__ == '__main__':
    # This block provides a simple command-line interface for demonstration.
    # It showcases the functionality and error handling of the Calculator.
    
    print("--- Console Arithmetic Calculator ---")
    print("Enter 'exit' or 'quit' to close.")
    print("Supports: +, -, *, /, (), integers, floats, and negative numbers.\n")

    calculator = Calculator()

    # --- Test Cases ---
    print("--- Running Built-in Test Cases ---")
    test_expressions = {
        "5 + 3": 8.0,
        "10 - 4": 6.0,
        "3 * 7": 21.0,
        "20 / 4": 5.0,
        "2 * (3 + 4)": 14.0,
        "(10 - 2) * 3": 24.0,
        "10 / (2.5 * 2)": 2.0,
        "3 + 4 * 2 / (1 - 5)": 1.0,
        "-3 * (4 - 2.5)": -4.5,
        "10.5 - -2.5": 13.0,
        "1 / 3": 0.3333333333333333,
        "-1 + -2 * -3": 5.0,
        "-.5 * (2)": -1.0
    }

    for expr, expected in test_expressions.items():
        try:
            result = calculator.calculate(expr)
            status = "PASS" if abs(result - expected) < 1e-9 else f"FAIL (Got: {result})"
            print(f"'{expr}' => {result:.4f} ... {status}")
        except Exception as e:
            print(f"'{expr}' => ERROR: {e} ... FAIL")
    
    print("\n--- Interactive Mode ---")

    while True:
        try:
            user_input = input(">>> ")
            if user_input.lower() in ['exit', 'quit']:
                print("Exiting calculator.")
                break
            
            result = calculator.calculate(user_input)
            print(f"= {result}")

        except (ValueError, ZeroDivisionError, RuntimeError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nExiting calculator.")
            break
```