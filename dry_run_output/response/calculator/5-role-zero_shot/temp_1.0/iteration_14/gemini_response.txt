Of course. As a senior software developer, I will create a robust, maintainable, and well-documented Python implementation for a console-based calculator. The design will strictly follow the provided requirements, with a special focus on the principles outlined in the ISO/IEC 25010 standard.

The chosen architecture involves three main stages, promoting modularity and testability:
1.  **Tokenizer**: Converts the input string into a list of tokens (numbers, operators, parentheses).
2.  **Infix to Postfix Conversion**: Uses the Shunting-yard algorithm to convert the infix token stream into Reverse Polish Notation (RPN), which simplifies evaluation by inherently handling operator precedence and parentheses.
3.  **RPN Evaluator**: Processes the RPN token stream to compute the final result.

This approach avoids the security risks of `eval()` while providing an efficient and scalable solution.

Here is the complete implementation:

```python
"""
A high-quality, console-based arithmetic calculator module.

This module provides a Calculator class that can parse and evaluate mathematical
expressions, adhering to the principles of the ISO/IEC 25010 standard for
software quality.
"""

from typing import List, Union

class Calculator:
    """
    A robust arithmetic calculator that evaluates string expressions.

    This class provides functionality to safely parse and compute standard
    arithmetic expressions, including support for addition, subtraction,

    multiplication, division, and parentheses. It is designed with a focus
    on correctness, safety, and maintainability.

    Core Algorithm:
    1. Tokenization: The input string is broken down into numbers and operators.
    2. Shunting-yard Algorithm: The infix expression (standard notation) is
       converted to a postfix expression (Reverse Polish Notation or RPN).
    3. RPN Evaluation: The RPN expression is evaluated using a stack.

    This avoids the use of `eval()`, preventing code injection vulnerabilities.
    """

    # --- Class Attributes for Configuration and Safety ---
    _OPERATORS = {
        '+': {'precedence': 1, 'func': lambda a, b: a + b},
        '-': {'precedence': 1, 'func': lambda a, b: a - b},
        '*': {'precedence': 2, 'func': lambda a, b: a * b},
        '/': {'precedence': 2, 'func': lambda a, b: a / b},
    }
    _PARENTHESES = {'(', ')'}

    def calculate(self, expression: str) -> float:
        """
        Evaluates a mathematical expression string and returns the result.

        This is the main public interface for the Calculator class.

        Args:
            expression: A string containing the mathematical expression to evaluate.
                        e.g., "3 + 5 * (2 - 8)"

        Returns:
            The final floating-point result of the expression.

        Raises:
            ValueError: If the expression is invalid (e.g., unbalanced parentheses,
                        invalid characters, malformed expression).
            ZeroDivisionError: If the expression contains a division by zero.
        """
        # ISO/IEC 25010 - Reliability (Maturity): Basic input validation
        if not isinstance(expression, str) or not expression.strip():
            raise ValueError("Input expression must be a non-empty string.")

        try:
            # 1. Tokenize the expression string
            tokens = self._tokenize(expression)

            # 2. Convert from infix to postfix (RPN) using Shunting-yard algorithm
            rpn_tokens = self._to_rpn(tokens)

            # 3. Evaluate the RPN expression
            result = self._evaluate_rpn(rpn_tokens)
            
            return result
        except (ValueError, ZeroDivisionError):
            # Re-raise specific, caught errors to the caller
            raise
        except Exception as e:
            # ISO/IEC 25010 - Reliability (Fault Tolerance): Catch unexpected errors
            # and wrap them in a standard error type for consistent API.
            raise ValueError(f"An unexpected error occurred during calculation: {e}") from e

    def _tokenize(self, expression: str) -> List[str]:
        """
        Converts the expression string into a list of tokens.

        This method handles integers, floats, and operators, while ignoring whitespace.
        It also performs initial character validation.

        Returns:
            A list of string tokens (e.g., ['3.5', '+', '(', '10', ')']).

        Raises:
            ValueError: If an unrecognized character is found.
        """
        # ISO/IEC 25010 - Modularity: Tokenization is a separate, logical step.
        tokens = []
        i = 0
        while i < len(expression):
            char = expression[i]

            if char.isspace():
                i += 1
                continue
            
            if char.isdigit() or (char == '.'):
                # Start of a number
                num_str = ""
                while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'):
                    num_str += expression[i]
                    i += 1
                
                if num_str.count('.') > 1:
                    raise ValueError(f"Invalid number format: '{num_str}'")
                tokens.append(num_str)
                continue

            if char in self._OPERATORS or char in self._PARENTHESES:
                tokens.append(char)
                i += 1
                continue
            
            # ISO/IEC 25010 - Security: Reject unknown characters.
            raise ValueError(f"Invalid character in expression: '{char}'")
        
        return tokens
    
    def _to_rpn(self, tokens: List[str]) -> List[Union[float, str]]:
        """
        Converts a list of infix tokens to postfix (RPN) using Shunting-yard.

        This method correctly handles operator precedence and parentheses. It also
        manages unary minus by looking at the preceding token.

        Returns:
            A list of tokens in RPN order. Numbers are converted to floats.

        Raises:
            ValueError: For mismatched parentheses or other malformed expressions.
        """
        # ISO/IEC 25010 - Modularity & Performance: Shunting-yard is an efficient (O(n))
        # and standard algorithm for this conversion.
        output_queue = []
        operator_stack = []

        for i, token in enumerate(tokens):
            if self._is_number(token):
                output_queue.append(float(token))
            elif token in self._OPERATORS:
                # Handle unary minus: if '-' is at the start or after an operator or '('.
                is_unary = (token == '-' and (i == 0 or tokens[i-1] in self._OPERATORS or tokens[i-1] == '('))
                
                if is_unary:
                    # To handle unary, we treat it as (0 - number). So we push a 0 to the
                    # output and treat the '-' as a binary operator.
                    output_queue.append(0.0)

                # Standard Shunting-yard logic for operators
                while (operator_stack and
                       operator_stack[-1] in self._OPERATORS and
                       self._OPERATORS[operator_stack[-1]]['precedence'] >= self._OPERATORS[token]['precedence']):
                    output_queue.append(operator_stack.pop())
                operator_stack.append(token)
            elif token == '(':
                operator_stack.append(token)
            elif token == ')':
                while operator_stack and operator_stack[-1] != '(':
                    output_queue.append(operator_stack.pop())
                
                # If stack is empty or top is not '(', parentheses are mismatched
                if not operator_stack or operator_stack.pop() != '(':
                    raise ValueError("Mismatched parentheses in expression")
            else:
                # This case should ideally not be reached due to tokenizer validation
                raise ValueError(f"Invalid token encountered: {token}")

        # Pop any remaining operators from the stack to the output
        while operator_stack:
            op = operator_stack.pop()
            if op == '(':
                # ISO/IEC 25010 - Correctness: Detect unbalanced parentheses.
                raise ValueError("Mismatched parentheses in expression")
            output_queue.append(op)
            
        return output_queue

    def _evaluate_rpn(self, rpn_tokens: List[Union[float, str]]) -> float:
        """
        Evaluates a list of tokens in Reverse Polish Notation (RPN).

        Returns:
            The final numerical result of the evaluation.

        Raises:
            ValueError: If the RPN expression is malformed.
            ZeroDivisionError: On division by zero.
        """
        # ISO/IEC 25010 - Correctness & Modularity: RPN evaluation is a distinct,
        # easy-to-test algorithm.
        operand_stack = []
        
        for token in rpn_tokens:
            if isinstance(token, float):
                operand_stack.append(token)
            elif token in self._OPERATORS:
                # ISO/IEC 25010 - Reliability (Fault Tolerance): Check for sufficient operands.
                if len(operand_stack) < 2:
                    raise ValueError("Invalid expression: Insufficient operands for operator")
                
                op2 = operand_stack.pop()
                op1 = operand_stack.pop()
                
                if token == '/' and op2 == 0:
                    raise ZeroDivisionError("Division by zero is not allowed.")
                
                operation = self._OPERATORS[token]['func']
                result = operation(op1, op2)
                operand_stack.append(result)
        
        if len(operand_stack) != 1:
            raise ValueError("Malformed expression, final stack has multiple values.")
            
        return operand_stack[0]

    @staticmethod
    def _is_number(s: str) -> bool:
        """Utility method to check if a string can be converted to a float."""
        try:
            float(s)
            return True
        except (ValueError, TypeError):
            return False


# --- Main execution block for demonstration and simple testing ---
# ISO/IEC 25010 - Testability: A simple, executable demo shows usage
# and verifies correctness for a range of inputs.
if __name__ == "__main__":
    print("--- Console Arithmetic Calculator ---")
    print("Enter an expression to evaluate or 'quit' to exit.")

    calculator = Calculator()

    # Define a set of test cases for verification
    test_cases = {
        "Simple addition": "5 + 3",
        "Simple subtraction": "10 - 4",
        "Simple multiplication": "6 * 7",
        "Simple division": "20 / 4",
        "Operator precedence": "2 + 3 * 4",
        "Parentheses": "(2 + 3) * 4",
        "Floating point numbers": "3.5 + 2.5 * 1.5",
        "Negative numbers": "-5 + 10",
        "Complex parentheses": "100 / (2 + 3) * 2 - (4 + 6 / 2)",
        "Unary minus complex": "5 * -2",
        "Combined unary minus": "10 - ( -5 * 2)",
        "Division by zero": "10 / 0",
        "Invalid character": "5 # 4",
        "Mismatched parentheses 1": "(5 + 3",
        "Mismatched parentheses 2": "5 + 3)",
        "Malformed expression": "5 * + 3",
    }
    
    print("\n--- Running Automated Test Cases ---")
    for name, expr in test_cases.items():
        try:
            result = calculator.calculate(expr)
            print(f"âœ… PASSED: '{expr}' => {result}")
        except (ValueError, ZeroDivisionError) as e:
            # For tests expected to fail, this is a "pass"
            print(f"ðŸ”¶ FAILED (as expected): '{expr}' => {type(e).__name__}: {e}")
        except Exception as e:
            print(f"âŒ ERROR: An unexpected error occurred for '{expr}' => {e}")

    print("\n--- Interactive Mode ---")
    while True:
        try:
            user_input = input(">>> ")
            if user_input.lower() == 'quit':
                break
            
            result = calculator.calculate(user_input)
            print(f"Result: {result}")
            
        except (ValueError, ZeroDivisionError) as e:
            print(f"Error: {e}")
        except Exception as e:
            print(f"An unexpected system error occurred: {e}")
```