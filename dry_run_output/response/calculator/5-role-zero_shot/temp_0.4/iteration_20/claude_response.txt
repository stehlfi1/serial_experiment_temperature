```python
"""
Console-based Arithmetic Calculator

A high-quality implementation of an arithmetic calculator that supports
basic operations (+, -, *, /) with parentheses and proper operator precedence.
Follows ISO/IEC 25010 quality standards.
"""

import re
from typing import List, Union
from enum import Enum


class TokenType(Enum):
    """Enumeration for different token types in mathematical expressions."""
    NUMBER = "NUMBER"
    OPERATOR = "OPERATOR"
    LEFT_PAREN = "LEFT_PAREN"
    RIGHT_PAREN = "RIGHT_PAREN"


class Token:
    """Represents a token in a mathematical expression."""
    
    def __init__(self, token_type: TokenType, value: str, position: int):
        """
        Initialize a token.
        
        Args:
            token_type: The type of the token
            value: The string value of the token
            position: The position in the original expression
        """
        self.type = token_type
        self.value = value
        self.position = position
    
    def __repr__(self) -> str:
        return f"Token({self.type}, {self.value}, {self.position})"


class CalculatorError(Exception):
    """Base exception class for calculator-related errors."""
    pass


class InvalidExpressionError(CalculatorError):
    """Raised when the expression is syntactically invalid."""
    pass


class DivisionByZeroError(CalculatorError):
    """Raised when attempting to divide by zero."""
    pass


class Calculator:
    """
    A console-based arithmetic calculator that evaluates mathematical expressions.
    
    Supports:
    - Basic operations: +, -, *, /
    - Parentheses for grouping
    - Integer and floating-point numbers (including negative values)
    - Proper operator precedence
    """
    
    # Operator precedence mapping (higher values = higher precedence)
    PRECEDENCE = {'+': 1, '-': 1, '*': 2, '/': 2}
    
    # Valid operators
    OPERATORS = {'+', '-', '*', '/'}
    
    def __init__(self):
        """Initialize the calculator."""
        self._reset_state()
    
    def _reset_state(self) -> None:
        """Reset internal state for a new calculation."""
        self._tokens: List[Token] = []
        self._current_position = 0
    
    def calculate(self, expression: str) -> float:
        """
        Evaluate a mathematical expression and return the result.
        
        Args:
            expression: A string containing the mathematical expression
            
        Returns:
            The calculated result as a float
            
        Raises:
            InvalidExpressionError: If the expression is syntactically invalid
            DivisionByZeroError: If division by zero is attempted
            
        Examples:
            >>> calc = Calculator()
            >>> calc.calculate("2 + 3 * 4")
            14.0
            >>> calc.calculate("(10 - 5) * 2")
            10.0
            >>> calc.calculate("-3.5 + 2.1")
            -1.4
        """
        if not expression or not expression.strip():
            raise InvalidExpressionError("Empty expression")
        
        self._reset_state()
        
        try:
            # Step 1: Tokenize the expression
            self._tokenize(expression.strip())
            
            # Step 2: Validate tokens
            self._validate_tokens()
            
            # Step 3: Convert to postfix notation (Shunting Yard algorithm)
            postfix_tokens = self._infix_to_postfix()
            
            # Step 4: Evaluate postfix expression
            result = self._evaluate_postfix(postfix_tokens)
            
            return float(result)
            
        except (ValueError, IndexError) as e:
            raise InvalidExpressionError(f"Invalid expression: {str(e)}")
    
    def _tokenize(self, expression: str) -> None:
        """
        Tokenize the input expression into numbers, operators, and parentheses.
        
        Args:
            expression: The mathematical expression to tokenize
            
        Raises:
            InvalidExpressionError: If invalid characters are found
        """
        # Regular expression to match numbers (including negative), operators, and parentheses
        pattern = r'(-?\d+\.?\d*)|([+\-*/()])'
        matches = re.finditer(pattern, expression)
        
        position = 0
        previous_token_type = None
        
        for match in matches:
            if match.start() != position:
                # There are invalid characters between tokens
                invalid_char = expression[position:match.start()].strip()
                if invalid_char:
                    raise InvalidExpressionError(
                        f"Invalid character(s) '{invalid_char}' at position {position}"
                    )
            
            token_value = match.group(0)
            position = match.end()
            
            # Determine token type
            if token_value == '(':
                token_type = TokenType.LEFT_PAREN
            elif token_value == ')':
                token_type = TokenType.RIGHT_PAREN
            elif token_value in self.OPERATORS:
                # Handle unary minus
                if (token_value == '-' and 
                    (previous_token_type is None or 
                     previous_token_type in [TokenType.LEFT_PAREN, TokenType.OPERATOR])):
                    # This is a unary minus, combine with next number
                    continue
                token_type = TokenType.OPERATOR
            else:
                # It's a number
                try:
                    float(token_value)  # Validate it's a valid number
                    token_type = TokenType.NUMBER
                except ValueError:
                    raise InvalidExpressionError(f"Invalid number '{token_value}'")
            
            self._tokens.append(Token(token_type, token_value, match.start()))
            previous_token_type = token_type
        
        # Check if there are remaining characters
        if position < len(expression):
            remaining = expression[position:].strip()
            if remaining:
                raise InvalidExpressionError(
                    f"Invalid character(s) '{remaining}' at position {position}"
                )
    
    def _validate_tokens(self) -> None:
        """
        Validate the sequence of tokens for syntactic correctness.
        
        Raises:
            InvalidExpressionError: If the token sequence is invalid
        """
        if not self._tokens:
            raise InvalidExpressionError("No valid tokens found")
        
        paren_count = 0
        previous_token = None
        
        for i, token in enumerate(self._tokens):
            # Check parentheses balance
            if token.type == TokenType.LEFT_PAREN:
                paren_count += 1
            elif token.type == TokenType.RIGHT_PAREN:
                paren_count -= 1
                if paren_count < 0:
                    raise InvalidExpressionError("Unbalanced parentheses: too many closing parentheses")
            
            # Validate token sequences
            if previous_token:
                self._validate_token_sequence(previous_token, token, i)
            
            previous_token = token
        
        # Check final parentheses balance
        if paren_count != 0:
            raise InvalidExpressionError("Unbalanced parentheses: missing closing parentheses")
        
        # Expression cannot start with binary operator or end with operator
        if self._tokens[0].type == TokenType.OPERATOR:
            raise InvalidExpressionError("Expression cannot start with an operator")
        
        if self._tokens[-1].type == TokenType.OPERATOR:
            raise InvalidExpressionError("Expression cannot end with an operator")
    
    def _validate_token_sequence(self, prev_token: Token, curr_token: Token, position: int) -> None:
        """
        Validate that two consecutive tokens form a valid sequence.
        
        Args:
            prev_token: The previous token
            curr_token: The current token
            position: The position of the current token
            
        Raises:
            InvalidExpressionError: If the sequence is invalid
        """
        # Define valid transitions
        valid_transitions = {
            TokenType.NUMBER: [TokenType.OPERATOR, TokenType.RIGHT_PAREN],
            TokenType.OPERATOR: [TokenType.NUMBER, TokenType.LEFT_PAREN],
            TokenType.LEFT_PAREN: [TokenType.NUMBER, TokenType.LEFT_PAREN],
            TokenType.RIGHT_PAREN: [TokenType.OPERATOR, TokenType.RIGHT_PAREN]
        }
        
        if curr_token.type not in valid_transitions[prev_token.type]:
            raise InvalidExpressionError(
                f"Invalid token sequence: '{prev_token.value}' followed by '{curr_token.value}' "
                f"at position {position}"
            )
    
    def _infix_to_postfix(self) -> List[Token]:
        """
        Convert infix expression to postfix notation using the Shunting Yard algorithm.
        
        Returns:
            List of tokens in postfix order
        """
        output_queue: List[Token] = []
        operator_stack: List[Token] = []
        
        for token in self._tokens:
            if token.type == TokenType.NUMBER:
                output_queue.append(token)
            
            elif token.type == TokenType.OPERATOR:
                # Pop operators with higher or equal precedence
                while (operator_stack and 
                       operator_stack[-1].type == TokenType.OPERATOR and
                       self.PRECEDENCE[operator_stack[-1].value] >= self.PRECEDENCE[token.value]):
                    output_queue.append(operator_stack.pop())
                operator_stack.append(token)
            
            elif token.type == TokenType.LEFT_PAREN:
                operator_stack.append(token)
            
            elif token.type == TokenType.RIGHT_PAREN:
                # Pop operators until left parenthesis
                while operator_stack and operator_stack[-1].type != TokenType.LEFT_PAREN:
                    output_queue.append(operator_stack.pop())
                
                # Remove the left parenthesis
                if operator_stack:
                    operator_stack.pop()
        
        # Pop remaining operators
        while operator_stack:
            output_queue.append(operator_stack.pop())
        
        return output_queue
    
    def _evaluate_postfix(self, tokens: List[Token]) -> float:
        """
        Evaluate a postfix expression.
        
        Args:
            tokens: List of tokens in postfix order
            
        Returns:
            The calculated result
            
        Raises:
            DivisionByZeroError: If division by zero is attempted
            InvalidExpressionError: If the expression is malformed
        """
        stack: List[float] = []
        
        for token in tokens:
            if token.type == TokenType.NUMBER:
                stack.append(float(token.value))
            
            elif token.type == TokenType.OPERATOR:
                if len(stack) < 2:
                    raise InvalidExpressionError("Insufficient operands for operator")
                
                # Pop two operands (note the order!)
                right_operand = stack.pop()
                left_operand = stack.pop()
                
                # Perform operation
                result = self._perform_operation(left_operand, token.value, right_operand)
                stack.append(result)
        
        if len(stack) != 1:
            raise InvalidExpressionError("Invalid expression: too many operands")
        
        return stack[0]
    
    def _perform_operation(self, left: float, operator: str, right: float) -> float:
        """
        Perform a binary arithmetic operation.
        
        Args:
            left: Left operand
            operator: The operator (+, -, *, /)
            right: Right operand
            
        Returns:
            The result of the operation
            
        Raises:
            DivisionByZeroError: If division by zero is attempted
        """
        if operator == '+':
            return left + right
        elif operator == '-':
            return left - right
        elif operator == '*':
            return left * right
        elif operator == '/':
            if right == 0:
                raise DivisionByZeroError("Division by zero")
            return left / right
        else:
            raise InvalidExpressionError(f"Unknown operator: {operator}")


def main():
    """
    Main function to run the calculator in interactive mode.
    """
    calculator = Calculator()
    
    print("Arithmetic Calculator")
    print("Supported operations: +, -, *, /")
    print("Supports parentheses and decimal numbers")
    print("Type 'quit' or 'exit' to stop\n")
    
    while True:
        try:
            expression = input("Enter expression: ").strip()
            
            if expression.lower() in ['quit', 'exit']:
                print("Goodbye!")
                break
            
            if not expression:
                continue
            
            result = calculator.calculate(expression)
            print(f"Result: {result}\n")
            
        except CalculatorError as e:
            print(f"Error: {e}\n")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Unexpected error: {e}\n")


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality arithmetic calculator that meets all the specified requirements:

## Key Features:

1. **Correctness**: Implements proper operator precedence and parentheses handling using the Shunting Yard algorithm
2. **Performance**: Uses efficient algorithms with O(n) time complexity for tokenization and evaluation
3. **Modularity**: Separated into logical components (tokenizer, validator, converter, evaluator)
4. **Safety**: Comprehensive input validation and custom exception handling
5. **Testability**: Clear separation of concerns and well-defined interfaces
6. **Readability**: Extensive documentation, clear variable names, and comprehensive comments

## Architecture:

- **Token/TokenType classes**: Represent parsed elements of the expression
- **Custom exceptions**: Specific error types for different failure modes
- **Calculator class**: Main interface with the required `calculate()` method
- **Modular methods**: Each step of the calculation process is separated

## Error Handling:

- Invalid characters and syntax
- Unbalanced parentheses
- Division by zero
- Empty expressions
- Invalid number formats

The code follows Python best practices and is designed to be maintainable, extensible, and robust.