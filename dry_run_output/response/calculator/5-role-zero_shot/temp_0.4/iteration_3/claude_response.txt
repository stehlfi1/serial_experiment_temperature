```python
"""
High-quality arithmetic calculator implementation following ISO/IEC 25010 standards.

This module provides a Calculator class that can evaluate mathematical expressions
with proper operator precedence, parentheses support, and comprehensive error handling.
"""

import re
from typing import List, Union
from enum import Enum


class TokenType(Enum):
    """Enumeration of token types for expression parsing."""
    NUMBER = "NUMBER"
    OPERATOR = "OPERATOR"
    LEFT_PAREN = "LEFT_PAREN"
    RIGHT_PAREN = "RIGHT_PAREN"


class Token:
    """Represents a token in a mathematical expression."""
    
    def __init__(self, token_type: TokenType, value: str, position: int):
        """
        Initialize a token.
        
        Args:
            token_type: The type of the token
            value: The string value of the token
            position: Position in the original expression
        """
        self.type = token_type
        self.value = value
        self.position = position
    
    def __repr__(self) -> str:
        return f"Token({self.type}, {self.value}, {self.position})"


class Calculator:
    """
    A high-quality arithmetic calculator that evaluates mathematical expressions.
    
    Supports basic arithmetic operations (+, -, *, /) with proper operator precedence,
    parentheses, and both integer and floating-point numbers including negative values.
    """
    
    # Operator precedence mapping (higher number = higher precedence)
    OPERATOR_PRECEDENCE = {
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2
    }
    
    # Valid operators
    OPERATORS = {'+', '-', '*', '/'}
    
    def __init__(self):
        """Initialize the calculator."""
        self._reset_state()
    
    def _reset_state(self) -> None:
        """Reset internal state for new calculation."""
        self._tokens: List[Token] = []
        self._current_position = 0
    
    def calculate(self, expression: str) -> float:
        """
        Evaluate a mathematical expression and return the result.
        
        Args:
            expression: Mathematical expression as a string
            
        Returns:
            The calculated result as a float
            
        Raises:
            ValueError: If the expression is invalid
            ZeroDivisionError: If division by zero is attempted
            
        Examples:
            >>> calc = Calculator()
            >>> calc.calculate("2 + 3 * 4")
            14.0
            >>> calc.calculate("(2 + 3) * 4")
            20.0
            >>> calc.calculate("-5 + 3")
            -2.0
        """
        if not expression or not expression.strip():
            raise ValueError("Expression cannot be empty")
        
        self._reset_state()
        
        try:
            # Tokenize the expression
            self._tokenize(expression.strip())
            
            # Validate tokens
            self._validate_tokens()
            
            # Convert to postfix notation using Shunting Yard algorithm
            postfix_tokens = self._to_postfix()
            
            # Evaluate postfix expression
            result = self._evaluate_postfix(postfix_tokens)
            
            return float(result)
            
        except (ValueError, ZeroDivisionError):
            raise
        except Exception as e:
            raise ValueError(f"Invalid expression: {str(e)}")
    
    def _tokenize(self, expression: str) -> None:
        """
        Tokenize the input expression into numbers, operators, and parentheses.
        
        Args:
            expression: The mathematical expression to tokenize
            
        Raises:
            ValueError: If invalid characters are found
        """
        # Remove all whitespace
        expression = re.sub(r'\s+', '', expression)
        
        i = 0
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit() or char == '.':
                # Parse number (integer or float)
                number_str, consumed = self._parse_number(expression, i)
                self._tokens.append(Token(TokenType.NUMBER, number_str, i))
                i += consumed
                
            elif char in self.OPERATORS:
                # Handle unary minus
                if char == '-' and self._is_unary_minus_position():
                    # Parse negative number
                    if i + 1 < len(expression) and (expression[i + 1].isdigit() or expression[i + 1] == '.'):
                        number_str, consumed = self._parse_number(expression, i + 1)
                        self._tokens.append(Token(TokenType.NUMBER, '-' + number_str, i))
                        i += consumed + 1
                    else:
                        # Unary minus before parentheses or invalid
                        self._tokens.append(Token(TokenType.NUMBER, '0', i))
                        self._tokens.append(Token(TokenType.OPERATOR, '-', i))
                        i += 1
                else:
                    self._tokens.append(Token(TokenType.OPERATOR, char, i))
                    i += 1
                    
            elif char == '(':
                self._tokens.append(Token(TokenType.LEFT_PAREN, char, i))
                i += 1
                
            elif char == ')':
                self._tokens.append(Token(TokenType.RIGHT_PAREN, char, i))
                i += 1
                
            else:
                raise ValueError(f"Invalid character '{char}' at position {i}")
    
    def _parse_number(self, expression: str, start: int) -> tuple[str, int]:
        """
        Parse a number (integer or float) from the expression.
        
        Args:
            expression: The full expression
            start: Starting position to parse from
            
        Returns:
            Tuple of (number_string, characters_consumed)
            
        Raises:
            ValueError: If the number format is invalid
        """
        i = start
        has_decimal = False
        
        while i < len(expression):
            char = expression[i]
            
            if char.isdigit():
                i += 1
            elif char == '.' and not has_decimal:
                has_decimal = True
                i += 1
            else:
                break
        
        number_str = expression[start:i]
        
        # Validate number format
        if not number_str or number_str == '.':
            raise ValueError(f"Invalid number format at position {start}")
        
        # Ensure the number is valid
        try:
            float(number_str)
        except ValueError:
            raise ValueError(f"Invalid number format '{number_str}' at position {start}")
        
        return number_str, i - start
    
    def _is_unary_minus_position(self) -> bool:
        """
        Determine if the current minus sign should be treated as unary.
        
        Returns:
            True if the minus should be treated as unary, False otherwise
        """
        if not self._tokens:
            return True
        
        last_token = self._tokens[-1]
        return (last_token.type == TokenType.OPERATOR or 
                last_token.type == TokenType.LEFT_PAREN)
    
    def _validate_tokens(self) -> None:
        """
        Validate the tokenized expression for correctness.
        
        Raises:
            ValueError: If the token sequence is invalid
        """
        if not self._tokens:
            raise ValueError("Empty expression")
        
        # Check for balanced parentheses
        paren_count = 0
        for token in self._tokens:
            if token.type == TokenType.LEFT_PAREN:
                paren_count += 1
            elif token.type == TokenType.RIGHT_PAREN:
                paren_count -= 1
                if paren_count < 0:
                    raise ValueError(f"Unmatched closing parenthesis at position {token.position}")
        
        if paren_count > 0:
            raise ValueError("Unmatched opening parenthesis")
        
        # Validate token sequence
        self._validate_token_sequence()
    
    def _validate_token_sequence(self) -> None:
        """
        Validate that the sequence of tokens follows proper mathematical syntax.
        
        Raises:
            ValueError: If the token sequence is invalid
        """
        for i, token in enumerate(self._tokens):
            if token.type == TokenType.OPERATOR:
                # Operators cannot be at the end
                if i == len(self._tokens) - 1:
                    raise ValueError(f"Expression cannot end with operator '{token.value}'")
                
                # Operators cannot be followed by operators (except unary minus)
                if i + 1 < len(self._tokens):
                    next_token = self._tokens[i + 1]
                    if (next_token.type == TokenType.OPERATOR and 
                        not (next_token.value == '-' and i + 2 < len(self._tokens))):
                        raise ValueError(f"Invalid operator sequence at position {token.position}")
            
            elif token.type == TokenType.RIGHT_PAREN:
                # Right parenthesis cannot be at the beginning
                if i == 0:
                    raise ValueError("Expression cannot start with closing parenthesis")
                
                # Right parenthesis must be preceded by number or right parenthesis
                prev_token = self._tokens[i - 1]
                if prev_token.type not in (TokenType.NUMBER, TokenType.RIGHT_PAREN):
                    raise ValueError(f"Invalid token before closing parenthesis at position {token.position}")
    
    def _to_postfix(self) -> List[Token]:
        """
        Convert infix expression to postfix notation using Shunting Yard algorithm.
        
        Returns:
            List of tokens in postfix order
        """
        output_queue: List[Token] = []
        operator_stack: List[Token] = []
        
        for token in self._tokens:
            if token.type == TokenType.NUMBER:
                output_queue.append(token)
                
            elif token.type == TokenType.OPERATOR:
                while (operator_stack and 
                       operator_stack[-1].type == TokenType.OPERATOR and
                       self.OPERATOR_PRECEDENCE[operator_stack[-1].value] >= 
                       self.OPERATOR_PRECEDENCE[token.value]):
                    output_queue.append(operator_stack.pop())
                operator_stack.append(token)
                
            elif token.type == TokenType.LEFT_PAREN:
                operator_stack.append(token)
                
            elif token.type == TokenType.RIGHT_PAREN:
                while (operator_stack and 
                       operator_stack[-1].type != TokenType.LEFT_PAREN):
                    output_queue.append(operator_stack.pop())
                
                if not operator_stack:
                    raise ValueError("Mismatched parentheses")
                
                # Remove the left parenthesis
                operator_stack.pop()
        
        # Pop remaining operators
        while operator_stack:
            if operator_stack[-1].type in (TokenType.LEFT_PAREN, TokenType.RIGHT_PAREN):
                raise ValueError("Mismatched parentheses")
            output_queue.append(operator_stack.pop())
        
        return output_queue
    
    def _evaluate_postfix(self, tokens: List[Token]) -> Union[int, float]:
        """
        Evaluate a postfix expression.
        
        Args:
            tokens: List of tokens in postfix order
            
        Returns:
            The calculated result
            
        Raises:
            ZeroDivisionError: If division by zero is attempted
            ValueError: If the expression is malformed
        """
        stack: List[Union[int, float]] = []
        
        for token in tokens:
            if token.type == TokenType.NUMBER:
                # Convert to appropriate numeric type
                value = float(token.value)
                if value.is_integer():
                    value = int(value)
                stack.append(value)
                
            elif token.type == TokenType.OPERATOR:
                if len(stack) < 2:
                    raise ValueError("Malformed expression: insufficient operands")
                
                right_operand = stack.pop()
                left_operand = stack.pop()
                
                result = self._apply_operator(token.value, left_operand, right_operand)
                stack.append(result)
        
        if len(stack) != 1:
            raise ValueError("Malformed expression: incorrect number of operands")
        
        return stack[0]
    
    def _apply_operator(self, operator: str, left: Union[int, float], 
                       right: Union[int, float]) -> Union[int, float]:
        """
        Apply an arithmetic operator to two operands.
        
        Args:
            operator: The operator to apply
            left: Left operand
            right: Right operand
            
        Returns:
            The result of the operation
            
        Raises:
            ZeroDivisionError: If division by zero is attempted
        """
        if operator == '+':
            result = left + right
        elif operator == '-':
            result = left - right
        elif operator == '*':
            result = left * right
        elif operator == '/':
            if right == 0:
                raise ZeroDivisionError("Division by zero")
            result = left / right
        else:
            raise ValueError(f"Unknown operator: {operator}")
        
        # Return integer if result is a whole number
        if isinstance(result, float) and result.is_integer():
            return int(result)
        return result


def main():
    """
    Main function to demonstrate calculator usage.
    Provides an interactive console interface for the calculator.
    """
    calculator = Calculator()
    
    print("Arithmetic Calculator")
    print("Supported operations: +, -, *, /, ()")
    print("Type 'quit' or 'exit' to stop")
    print("-" * 40)
    
    while True:
        try:
            expression = input("Enter expression: ").strip()
            
            if expression.lower() in ('quit', 'exit'):
                print("Goodbye!")
                break
            
            if not expression:
                continue
            
            result = calculator.calculate(expression)
            print(f"Result: {result}")
            
        except (ValueError, ZeroDivisionError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except EOFError:
            print("\nGoodbye!")
            break


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality arithmetic calculator that meets all the specified requirements:

## Key Features:

1. **Correctness**: Implements proper operator precedence, parentheses support, and handles both integers and floating-point numbers including negative values.

2. **Performance**: Uses the efficient Shunting Yard algorithm for expression parsing and evaluation with O(n) time complexity.

3. **Modularity**: Well-structured with separate classes for tokens, clear separation of concerns, and focused methods.

4. **Safety**: Comprehensive input validation, proper error handling with built-in exceptions, and protection against malformed expressions.

5. **Testability**: Clean interfaces, predictable behavior, and comprehensive error messages make testing straightforward.

6. **Readability**: Extensive docstrings, clear variable names, type hints, and detailed comments throughout.

## ISO/IEC 25010 Compliance:

- **Functional Suitability**: Correctly implements all required arithmetic operations
- **Performance Efficiency**: Efficient algorithms with optimal time complexity
- **Compatibility**: Pure Python implementation with no external dependencies
- **Usability**: Clear error messages and intuitive interface
- **Reliability**: Robust error handling and input validation
- **Security**: Safe input processing without using `eval()`
- **Maintainability**: Clean code structure, comprehensive documentation, and modular design
- **Portability**: Standard Python code that runs on any Python 3.6+ environment

The calculator can handle complex expressions like `"(-5 + 3) * (2.5 / 1.25)"` and provides meaningful error messages for invalid inputs.