Of course. As a senior software developer, I understand the importance of creating code that is not only functional but also robust, maintainable, and secure. Adhering to standards like ISO/IEC 25010 is key to achieving this.

Here is a high-quality Python implementation of a console-based calculator that meets all the specified requirements. The design is centered around the **Shunting-yard algorithm** for parsing the expression, which is an efficient and standard approach that correctly handles operator precedence and parentheses without using `eval()`.

### Rationale for ISO/IEC 25010 Adherence

*   **Functional Suitability:** The code correctly implements all required arithmetic operations, including parentheses and operator precedence, for both integers and floats.
*   **Performance Efficiency:** The implementation uses the Shunting-yard algorithm and a subsequent Reverse Polish Notation (RPN) evaluation, both of which operate in linear time (O(n)), making it highly efficient.
*   **Maintainability & Modularity:** The logic is broken down into distinct, private methods (`_tokenize`, `_to_rpn`, `_evaluate_rpn`), each with a single responsibility. This makes the code easier to understand, modify, and test.
*   **Reliability & Safety:** Robust validation is implemented at each stage. The tokenizer rejects invalid characters, the parser detects mismatched parentheses, and the evaluator handles division by zero. By explicitly avoiding `eval()`, we prevent code injection vulnerabilities.
*   **Testability:** The public `calculate` method provides a clear interface, and the modular internal methods can be unit-tested individually. The included `if __name__ == "__main__":` block serves as a basic integration test suite.
*   **Readability:** The code is thoroughly documented with docstrings, type hints, and comments explaining complex sections. Variable names are descriptive and follow PEP 8 conventions.

---

```python
import operator

class Calculator:
    """
    A high-quality, maintainable calculator that evaluates arithmetic expressions.

    This class adheres to the principles of ISO/IEC 25010 by focusing on:
    - Functional Suitability: Correctly evaluates expressions with +, -, *, /,
      parentheses, and operator precedence.
    - Performance Efficiency: Implements the Shunting-yard algorithm for
      efficient O(n) parsing.
    - Reliability & Safety: Provides robust validation against invalid input,
      unbalanced parentheses, division by zero, and malformed expressions.
      Crucially, it avoids the use of `eval()` to prevent security risks.
    - Maintainability & Modularity: Logic is separated into tokenization,
      parsing (infix to RPN), and evaluation steps.
    - Testability: The modular design allows for easy unit testing of each
      component.
    - Readability: Code is documented with docstrings, comments, and clear
      variable names.
    """

    def __init__(self):
        """Initializes the calculator, defining operators and their properties."""
        self._operators = {
            '+': {'precedence': 1, 'func': operator.add},
            '-': {'precedence': 1, 'func': operator.sub},
            '*': {'precedence': 2, 'func': operator.mul},
            '/': {'precedence': 2, 'func': operator.truediv}
        }
        self._parentheses = {'(', ')'}

    def calculate(self, expression: str) -> float:
        """
        Evaluates a given arithmetic expression string.

        This is the main public interface that orchestrates the tokenization,
        parsing, and evaluation of the expression.

        Args:
            expression: The arithmetic expression string to evaluate.

        Returns:
            The result of the evaluation as a float.

        Raises:
            ValueError: If the expression contains invalid characters,
                        unbalanced parentheses, or is malformed.
            ZeroDivisionError: If the expression attempts to divide by zero.
        """
        try:
            tokens = self._tokenize(expression)
            rpn_queue = self._to_rpn(tokens)
            result = self._evaluate_rpn(rpn_queue)
            return result
        except (ValueError, ZeroDivisionError) as e:
            # Re-raise exceptions to be handled by the caller, providing a clean interface.
            raise e
        except IndexError:
            # An IndexError during evaluation typically means a malformed expression
            # (e.g., "5 *").
            raise ValueError("Malformed expression: operator is missing an operand.")

    def _tokenize(self, expression: str) -> list[str | float]:
        """
        Converts the input expression string into a list of tokens.

        This method handles numbers (integers, floats, negatives) and operators.
        It correctly identifies unary minus at the beginning of an expression
        or after an operator/opening parenthesis.

        Args:
            expression: The raw expression string.

        Returns:
            A list of tokens (numbers as floats, operators/parentheses as strings).

        Raises:
            ValueError: If an invalid character is found in the expression.
        """
        tokens = []
        i = 0
        while i < len(expression):
            char = expression[i]

            if char.isspace():
                i += 1
                continue

            # Check for numbers (including floating point and unary minus)
            if char.isdigit() or (char == '.'):
                num_str, i = self._extract_number(expression, i)
                tokens.append(float(num_str))
                continue
            
            # Handle unary minus
            if char == '-' and (i == 0 or expression[i-1] in self._operators or expression[i-1] == '('):
                num_str, i = self._extract_number(expression, i)
                tokens.append(float(num_str))
                continue

            if char in self._operators or char in self._parentheses:
                tokens.append(char)
                i += 1
                continue

            raise ValueError(f"Invalid character in expression: '{char}'")

        return tokens

    def _extract_number(self, expression: str, start_index: int) -> tuple[str, int]:
        """Helper to extract a full number string from the expression."""
        j = start_index
        # Handle potential leading unary minus
        if expression[j] == '-':
            j += 1
            
        while j < len(expression) and (expression[j].isdigit() or expression[j] == '.'):
            j += 1
        
        num_str = expression[start_index:j]
        if num_str == '-' or num_str.count('.') > 1:
            raise ValueError(f"Malformed number '{num_str}' in expression.")
            
        return num_str, j


    def _to_rpn(self, tokens: list[str | float]) -> list[str | float]:
        """
        Converts a token list from infix notation to Reverse Polish Notation (RPN).

        This method implements the Shunting-yard algorithm.

        Args:
            tokens: A list of tokens from the _tokenize method.

        Returns:
            A list of tokens in RPN order.

        Raises:
            ValueError: If the expression has mismatched parentheses.
        """
        output_queue = []
        operator_stack = []

        for token in tokens:
            if isinstance(token, float):
                output_queue.append(token)
            elif token in self._operators:
                # While stack is not empty, top is not '(', and has higher/equal precedence
                while (operator_stack and operator_stack[-1] != '(' and
                       self._operators.get(operator_stack[-1], {}).get('precedence', 0) >=
                       self._operators[token]['precedence']):
                    output_queue.append(operator_stack.pop())
                operator_stack.append(token)
            elif token == '(':
                operator_stack.append(token)
            elif token == ')':
                while operator_stack and operator_stack[-1] != '(':
                    output_queue.append(operator_stack.pop())
                
                if not operator_stack or operator_stack[-1] != '(':
                    raise ValueError("Mismatched parentheses in expression.")
                operator_stack.pop()  # Discard the '('

        # Pop any remaining operators from the stack to the queue
        while operator_stack:
            op = operator_stack.pop()
            if op == '(':
                raise ValueError("Mismatched parentheses in expression.")
            output_queue.append(op)

        return output_queue

    def _evaluate_rpn(self, rpn_queue: list[str | float]) -> float:
        """
        Evaluates a token queue in Reverse Polish Notation (RPN).

        Args:
            rpn_queue: A list of tokens in RPN order.

        Returns:
            The final calculated result.

        Raises:
            ZeroDivisionError: If division by zero occurs.
            ValueError: If the RPN queue is malformed.
        """
        operand_stack = []

        for token in rpn_queue:
            if isinstance(token, float):
                operand_stack.append(token)
            elif token in self._operators:
                # Operator requires two operands
                if len(operand_stack) < 2:
                    raise ValueError("Malformed expression: not enough operands for operator.")
                
                operand2 = operand_stack.pop()
                operand1 = operand_stack.pop()
                
                operation = self._operators[token]['func']

                if token == '/' and operand2 == 0:
                    raise ZeroDivisionError("Division by zero is not allowed.")
                
                result = operation(operand1, operand2)
                operand_stack.append(result)

        if len(operand_stack) != 1:
            raise ValueError("Malformed expression: too many operands.")

        return operand_stack[0]


if __name__ == "__main__":
    # This block demonstrates the usage of the Calculator class and serves as
    # a basic set of integration tests.
    calc = Calculator()
    
    print("--- Console Arithmetic Calculator ---")
    print("Enter an expression to evaluate or 'exit' to quit.")

    # Example test cases
    test_expressions = {
        "Simple addition": "5 + 3",
        "Operator precedence": "5 + 3 * 2",
        "Parentheses": "(5 + 3) * 2",
        "Floating point numbers": "7.5 / 2.5",
        "Negative numbers": "-10 + ( -5 * 2 )",
        "Complex expression": "3 * (3 + 1) / 6 - 2",
        "Unary minus start": "-5 * 2",
        "Unary minus after operator": "10 * -2",
        "Chained operations": "100 / 10 * 2",
        "Invalid character": "5 @ 2",
        "Division by zero": "10 / (5 - 5)",
        "Mismatched parentheses (extra close)": "((5+3)*2))",
        "Mismatched parentheses (extra open)": "((5+3*2)",
        "Malformed expression": "5 * + 3",
    }

    print("\n--- Running Automated Test Cases ---")
    for name, expr in test_expressions.items():
        try:
            result = calc.calculate(expr)
            print(f"'{expr}' = {result:<15} ✅ ({name})")
        except (ValueError, ZeroDivisionError) as e:
            print(f"'{expr}' -> Error: {e:<15} ✅ ({name})")
    
    print("\n--- Interactive Mode ---")
    while True:
        try:
            user_input = input("> ")
            if user_input.lower() == 'exit':
                break
            if not user_input:
                continue
            
            result = calc.calculate(user_input)
            print(f"= {result}")

        except (ValueError, ZeroDivisionError) as e:
            print(f"Error: {e}")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")

```