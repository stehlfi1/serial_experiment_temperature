```python
"""
ASCII Art Generator

A high-quality, maintainable Python application for generating 2D ASCII art shapes.
Implements ISO/IEC 25010 quality standards with focus on correctness, performance,
modularity, safety, testability, and readability.

Author: Senior Software Developer
Version: 1.0.0
"""

from typing import Union


class AsciiArtError(Exception):
    """Base exception class for ASCII Art related errors."""
    pass


class InvalidSymbolError(AsciiArtError):
    """Raised when an invalid symbol is provided."""
    pass


class InvalidDimensionError(AsciiArtError):
    """Raised when invalid dimensions are provided."""
    pass


class AsciiArt:
    """
    A class for generating various ASCII art shapes.
    
    This class provides methods to draw different geometric shapes using ASCII characters.
    All shapes are filled with the specified symbol and returned as multi-line strings.
    
    The class ensures input validation and follows defensive programming practices
    to maintain robustness and reliability.
    """
    
    @staticmethod
    def _validate_symbol(symbol: str) -> None:
        """
        Validate the symbol parameter.
        
        Args:
            symbol: The character to use for drawing
            
        Raises:
            InvalidSymbolError: If symbol is not a single printable character
        """
        if not isinstance(symbol, str):
            raise InvalidSymbolError("Symbol must be a string")
        
        if len(symbol) != 1:
            raise InvalidSymbolError("Symbol must be exactly one character")
        
        if symbol.isspace():
            raise InvalidSymbolError("Symbol cannot be a whitespace character")
        
        if not symbol.isprintable():
            raise InvalidSymbolError("Symbol must be a printable character")
    
    @staticmethod
    def _validate_positive_dimension(value: int, name: str) -> None:
        """
        Validate that a dimension is a positive integer.
        
        Args:
            value: The dimension value to validate
            name: The name of the dimension for error messages
            
        Raises:
            InvalidDimensionError: If value is not a positive integer
        """
        if not isinstance(value, int):
            raise InvalidDimensionError(f"{name} must be an integer")
        
        if value <= 0:
            raise InvalidDimensionError(f"{name} must be positive (greater than 0)")
    
    @staticmethod
    def _validate_non_negative_dimension(value: int, name: str) -> None:
        """
        Validate that a dimension is a non-negative integer.
        
        Args:
            value: The dimension value to validate
            name: The name of the dimension for error messages
            
        Raises:
            InvalidDimensionError: If value is not a non-negative integer
        """
        if not isinstance(value, int):
            raise InvalidDimensionError(f"{name} must be an integer")
        
        if value < 0:
            raise InvalidDimensionError(f"{name} must be non-negative")
    
    def draw_square(self, width: int, symbol: str) -> str:
        """
        Draw a square filled with the specified symbol.
        
        Args:
            width: The width and height of the square (must be positive)
            symbol: Single printable character to fill the square
            
        Returns:
            Multi-line string representing the ASCII square
            
        Raises:
            InvalidDimensionError: If width is not a positive integer
            InvalidSymbolError: If symbol is invalid
            
        Example:
            >>> art = AsciiArt()
            >>> print(art.draw_square(3, '*'))
            ***
            ***
            ***
        """
        self._validate_positive_dimension(width, "width")
        self._validate_symbol(symbol)
        
        # Efficient string construction using list comprehension and join
        lines = [symbol * width for _ in range(width)]
        return '\n'.join(lines)
    
    def draw_rectangle(self, width: int, height: int, symbol: str) -> str:
        """
        Draw a rectangle filled with the specified symbol.
        
        Args:
            width: The width of the rectangle (must be positive)
            height: The height of the rectangle (must be positive)
            symbol: Single printable character to fill the rectangle
            
        Returns:
            Multi-line string representing the ASCII rectangle
            
        Raises:
            InvalidDimensionError: If width or height is not a positive integer
            InvalidSymbolError: If symbol is invalid
            
        Example:
            >>> art = AsciiArt()
            >>> print(art.draw_rectangle(4, 2, '#'))
            ####
            ####
        """
        self._validate_positive_dimension(width, "width")
        self._validate_positive_dimension(height, "height")
        self._validate_symbol(symbol)
        
        # Efficient string construction using list comprehension and join
        lines = [symbol * width for _ in range(height)]
        return '\n'.join(lines)
    
    def draw_parallelogram(self, width: int, height: int, symbol: str) -> str:
        """
        Draw a parallelogram filled with the specified symbol.
        
        The parallelogram grows diagonally to the right, starting from the top-left corner.
        Each row is shifted by one space to the right compared to the previous row.
        
        Args:
            width: The width of each row (must be positive)
            height: The height of the parallelogram (must be positive)
            symbol: Single printable character to fill the parallelogram
            
        Returns:
            Multi-line string representing the ASCII parallelogram
            
        Raises:
            InvalidDimensionError: If width or height is not a positive integer
            InvalidSymbolError: If symbol is invalid
            
        Example:
            >>> art = AsciiArt()
            >>> print(art.draw_parallelogram(3, 3, '*'))
            ***
             ***
              ***
        """
        self._validate_positive_dimension(width, "width")
        self._validate_positive_dimension(height, "height")
        self._validate_symbol(symbol)
        
        # Efficient construction with calculated spacing
        lines = [' ' * i + symbol * width for i in range(height)]
        return '\n'.join(lines)
    
    def draw_triangle(self, width: int, height: int, symbol: str) -> str:
        """
        Draw a right-angled triangle filled with the specified symbol.
        
        The triangle grows diagonally to the right, starting from the top-left corner.
        Each row contains an increasing number of symbols.
        
        Args:
            width: The maximum width of the triangle base (must be positive)
            height: The height of the triangle (must be positive)
            symbol: Single printable character to fill the triangle
            
        Returns:
            Multi-line string representing the ASCII triangle
            
        Raises:
            InvalidDimensionError: If width or height is not a positive integer
            InvalidSymbolError: If symbol is invalid
            
        Example:
            >>> art = AsciiArt()
            >>> print(art.draw_triangle(4, 4, '*'))
            *
            **
            ***
            ****
        """
        self._validate_positive_dimension(width, "width")
        self._validate_positive_dimension(height, "height")
        self._validate_symbol(symbol)
        
        # Calculate symbols per row efficiently
        lines = []
        for i in range(height):
            # Calculate number of symbols for this row
            symbols_count = min(i + 1, width)
            lines.append(symbol * symbols_count)
        
        return '\n'.join(lines)
    
    def draw_pyramid(self, height: int, symbol: str) -> str:
        """
        Draw a symmetrical pyramid filled with the specified symbol.
        
        The pyramid is centered and grows symmetrically from top to bottom.
        Each row contains an odd number of symbols, increasing by 2 each row.
        
        Args:
            height: The height of the pyramid (must be positive)
            symbol: Single printable character to fill the pyramid
            
        Returns:
            Multi-line string representing the ASCII pyramid
            
        Raises:
            InvalidDimensionError: If height is not a positive integer
            InvalidSymbolError: If symbol is invalid
            
        Example:
            >>> art = AsciiArt()
            >>> print(art.draw_pyramid(4, '*'))
               *
              ***
             *****
            *******
        """
        self._validate_positive_dimension(height, "height")
        self._validate_symbol(symbol)
        
        # Calculate maximum width for centering
        max_width = 2 * height - 1
        
        lines = []
        for i in range(height):
            # Number of symbols in current row (odd numbers: 1, 3, 5, ...)
            symbols_count = 2 * i + 1
            # Number of leading spaces for centering
            leading_spaces = (max_width - symbols_count) // 2
            
            line = ' ' * leading_spaces + symbol * symbols_count
            lines.append(line)
        
        return '\n'.join(lines)


def main():
    """
    Demonstration function showing usage of the AsciiArt class.
    
    This function serves as both a usage example and a basic integration test.
    """
    try:
        art = AsciiArt()
        
        print("ASCII Art Generator Demo")
        print("=" * 30)
        
        # Demonstrate square
        print("\nSquare (5x5, '*'):")
        print(art.draw_square(5, '*'))
        
        # Demonstrate rectangle
        print("\nRectangle (6x3, '#'):")
        print(art.draw_rectangle(6, 3, '#'))
        
        # Demonstrate parallelogram
        print("\nParallelogram (4x4, '+'):")
        print(art.draw_parallelogram(4, 4, '+'))
        
        # Demonstrate triangle
        print("\nTriangle (5x5, '>'):")
        print(art.draw_triangle(5, 5, '>'))
        
        # Demonstrate pyramid
        print("\nPyramid (6, '^'):")
        print(art.draw_pyramid(6, '^'))
        
        # Demonstrate error handling
        print("\nError handling demonstration:")
        try:
            art.draw_square(-1, '*')
        except InvalidDimensionError as e:
            print(f"Caught expected error: {e}")
        
        try:
            art.draw_rectangle(3, 3, '  ')  # Multi-character symbol
        except InvalidSymbolError as e:
            print(f"Caught expected error: {e}")
            
    except Exception as e:
        print(f"Unexpected error: {e}")


if __name__ == "__main__":
    main()
```

This implementation adheres to ISO/IEC 25010 quality standards:

## **Quality Characteristics Addressed:**

### **Functional Suitability**
- ✅ **Correctness**: All functions produce expected ASCII art shapes
- ✅ **Completeness**: Implements all required drawing functions
- ✅ **Appropriateness**: Each function serves its specific purpose

### **Performance Efficiency**
- ✅ **Time Behavior**: Uses efficient algorithms (O(n) complexity where n is the number of characters)
- ✅ **Resource Utilization**: Minimal memory usage with list comprehensions and string joins

### **Compatibility**
- ✅ **Interoperability**: Standard Python with type hints for better integration

### **Usability**
- ✅ **Appropriateness Recognizability**: Clear method names and documentation
- ✅ **Learnability**: Comprehensive docstrings with examples
- ✅ **User Error Protection**: Robust input validation

### **Reliability**
- ✅ **Maturity**: Defensive programming with comprehensive error handling
- ✅ **Fault Tolerance**: Custom exception hierarchy for different error types
- ✅ **Recoverability**: Clear error messages for debugging

### **Security**
- ✅ **Confidentiality**: No sensitive data exposure
- ✅ **Integrity**: Input validation prevents malformed output

### **Maintainability**
- ✅ **Modularity**: Separate validation methods and clear separation of concerns
- ✅ **Reusability**: Static validation methods can be reused
- ✅ **Analysability**: Clear structure and comprehensive documentation
- ✅ **Modifiability**: Easy to extend with new shapes
- ✅ **Testability**: Each method is independently testable

### **Portability**
- ✅ **Adaptability**: Pure Python implementation works across platforms
- ✅ **Installability**: No external dependencies

The code follows best practices including comprehensive input validation, efficient algorithms, clear documentation, and proper error handling.