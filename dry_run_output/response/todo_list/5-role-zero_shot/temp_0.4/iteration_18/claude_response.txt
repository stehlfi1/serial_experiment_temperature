```python
"""
High-Quality Todo List Application
Implements a console-based task management system following ISO/IEC 25010 standards.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Data class representing a task with all its attributes.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime


class TaskManager:
    """
    A thread-safe task management system for handling todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, and updating tasks. It implements efficient
    data structures and proper error handling following ISO/IEC 25010 standards.
    """
    
    def __init__(self) -> None:
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a lock for thread safety.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()
    
    def _validate_task_name(self, task_name: str) -> None:
        """
        Validate task name input.
        
        Args:
            task_name (str): The task name to validate
            
        Raises:
            TypeError: If task_name is not a string
            ValueError: If task_name is empty or only whitespace
        """
        if not isinstance(task_name, str):
            raise TypeError("Task name must be a string")
        if not task_name or not task_name.strip():
            raise ValueError("Task name cannot be empty or only whitespace")
    
    def _validate_task_description(self, task_description: str) -> None:
        """
        Validate task description input.
        
        Args:
            task_description (str): The task description to validate
            
        Raises:
            TypeError: If task_description is not a string
            ValueError: If task_description is empty or only whitespace
        """
        if not isinstance(task_description, str):
            raise TypeError("Task description must be a string")
        if not task_description or not task_description.strip():
            raise ValueError("Task description cannot be empty or only whitespace")
    
    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID input.
        
        Args:
            task_id (int): The task ID to validate
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer")
        if task_id <= 0:
            raise ValueError("Task ID must be a positive integer")
    
    def _validate_search_term(self, task_term: str) -> None:
        """
        Validate search term input.
        
        Args:
            task_term (str): The search term to validate
            
        Raises:
            TypeError: If task_term is not a string
            ValueError: If task_term is empty or only whitespace
        """
        if not isinstance(task_term, str):
            raise TypeError("Search term must be a string")
        if not task_term or not task_term.strip():
            raise ValueError("Search term cannot be empty or only whitespace")
    
    def _task_exists(self, task_id: int) -> bool:
        """
        Check if a task with the given ID exists.
        
        Args:
            task_id (int): The task ID to check
            
        Returns:
            bool: True if task exists, False otherwise
        """
        return task_id in self._tasks
    
    def _task_to_dict(self, task: Task) -> Dict:
        """
        Convert a Task object to dictionary format for external consumption.
        
        Args:
            task (Task): The task object to convert
            
        Returns:
            Dict: Dictionary containing task information
        """
        task_dict = asdict(task)
        # Remove internal timestamp for cleaner external interface
        task_dict.pop('created_at', None)
        return task_dict
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): Name of the task (non-empty string)
            task_description (str): Description of the task (non-empty string)
            
        Returns:
            int: Unique ID assigned to the new task
            
        Raises:
            TypeError: If inputs are not strings
            ValueError: If inputs are empty or only whitespace
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        self._validate_task_name(task_name)
        self._validate_task_description(task_description)
        
        with self._lock:
            task_id = self._next_id
            task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip(),
                is_finished=False,
                created_at=datetime.now()
            )
            self._tasks[task_id] = task
            self._next_id += 1
            
        return task_id
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list by its ID.
        
        Args:
            task_id (int): ID of the task to remove (positive integer)
            
        Returns:
            bool: True if task was successfully removed, False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is not positive
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            if self._task_exists(task_id):
                del self._tasks[task_id]
                return True
            return False
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description containing the search term.
        
        Args:
            task_term (str): Term to search for (non-empty string)
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            TypeError: If task_term is not a string
            ValueError: If task_term is empty or only whitespace
            
        Time Complexity: O(n) where n is the number of tasks
        Space Complexity: O(k) where k is the number of matching tasks
        """
        self._validate_search_term(task_term)
        
        search_term_lower = task_term.strip().lower()
        matching_tasks = []
        
        with self._lock:
            for task in self._tasks.values():
                if (search_term_lower in task.task_name.lower() or 
                    search_term_lower in task.task_description.lower()):
                    matching_tasks.append(self._task_to_dict(task))
        
        # Sort by task ID for consistent ordering
        matching_tasks.sort(key=lambda x: x['id'])
        return matching_tasks
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): ID of the task to mark as finished (positive integer)
            
        Returns:
            bool: True if task was successfully marked as finished, False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is not positive
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            if self._task_exists(task_id):
                self._tasks[task_id].is_finished = True
                return True
            return False
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks in the todo list.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, sorted by ID
            
        Time Complexity: O(n log n) where n is the number of tasks (due to sorting)
        Space Complexity: O(n) where n is the number of tasks
        """
        with self._lock:
            all_tasks = [self._task_to_dict(task) for task in self._tasks.values()]
        
        # Sort by task ID for consistent ordering
        all_tasks.sort(key=lambda x: x['id'])
        return all_tasks
    
    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: Always returns True indicating successful operation
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        with self._lock:
            self._tasks.clear()
            self._next_id = 1
        return True
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Total number of tasks in the system
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
            
        Time Complexity: O(n) where n is the number of tasks
        Space Complexity: O(1)
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)


def main():
    """
    Demonstration of the TaskManager functionality.
    
    This function provides a simple console interface to interact with
    the TaskManager and demonstrates all available operations.
    """
    task_manager = TaskManager()
    
    print("=== Todo List Application ===")
    print("Available commands: add, remove, search, finish, list, clear, quit")
    
    while True:
        try:
            command = input("\nEnter command: ").strip().lower()
            
            if command == "quit":
                print("Goodbye!")
                break
            elif command == "add":
                name = input("Task name: ").strip()
                description = input("Task description: ").strip()
                task_id = task_manager.add(name, description)
                print(f"Task added with ID: {task_id}")
            
            elif command == "remove":
                task_id = int(input("Task ID to remove: "))
                if task_manager.remove(task_id):
                    print("Task removed successfully")
                else:
                    print("Task not found")
            
            elif command == "search":
                term = input("Search term: ").strip()
                results = task_manager.search(term)
                if results:
                    print(f"Found {len(results)} matching task(s):")
                    for task in results:
                        status = "✓" if task['is_finished'] else "○"
                        print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
                else:
                    print("No matching tasks found")
            
            elif command == "finish":
                task_id = int(input("Task ID to finish: "))
                if task_manager.finish(task_id):
                    print("Task marked as finished")
                else:
                    print("Task not found")
            
            elif command == "list":
                tasks = task_manager.get_all()
                if tasks:
                    print(f"All tasks ({len(tasks)} total):")
                    for task in tasks:
                        status = "✓" if task['is_finished'] else "○"
                        print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
                else:
                    print("No tasks found")
            
            elif command == "clear":
                confirm = input("Are you sure you want to clear all tasks? (y/N): ").strip().lower()
                if confirm == 'y':
                    task_manager.clear_all()
                    print("All tasks cleared")
                else:
                    print("Operation cancelled")
            
            else:
                print("Unknown command. Available: add, remove, search, finish, list, clear, quit")
        
        except (ValueError, TypeError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality, maintainable todo list application that meets ISO/IEC 25010 standards with the following key features:

## Quality Characteristics Addressed:

1. **Functional Suitability**: All required methods implemented with correct behavior
2. **Performance Efficiency**: O(1) operations for add/remove/finish, efficient data structures
3. **Compatibility**: Standard Python types and threading support
4. **Usability**: Clear error messages and intuitive interface
5. **Reliability**: Comprehensive input validation and error handling
6. **Security**: Input sanitization and type checking
7. **Maintainability**: Clean OOP design, comprehensive documentation, modular structure
8. **Portability**: Pure Python implementation with standard library only

## Key Features:

- **Thread-safe operations** using RLock
- **Comprehensive input validation** with meaningful error messages
- **Efficient data structures** (dictionary for O(1) lookups)
- **Clean separation of concerns** with helper methods
- **Extensive documentation** with docstrings and type hints
- **Error handling** for all edge cases
- **Consistent return formats** as specified
- **Additional utility methods** for enhanced functionality

The code is production-ready, easily testable, and follows Python best practices while maintaining high performance and reliability.