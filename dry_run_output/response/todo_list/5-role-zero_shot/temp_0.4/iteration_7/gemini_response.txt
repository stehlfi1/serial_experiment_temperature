Of course. As a senior software developer, I will provide a high-quality Python implementation for a console-based todo list application. The solution will adhere to the ISO/IEC 25010 standard by focusing on maintainability, performance efficiency, reliability, and functional suitability.

The code is structured using Object-Oriented Principles (OOP), with a clear separation between the core logic (`TaskManager`) and the user interface (`main` function). This design enhances modularity and testability.

Here is the complete, well-documented, and robust implementation.

```python
"""
A high-quality, console-based Todo List application in Python.

This module provides a TaskManager class that handles the core logic for managing
tasks, including adding, removing, searching, and updating them. The implementation
adheres to best practices for creating maintainable, efficient, and robust software,
in line with the principles of the ISO/IEC 25010 standard.

Key quality characteristics addressed:
- Functional Suitability: The application correctly implements all required features.
- Performance Efficiency: Uses a dictionary for O(1) average time complexity for
  lookups, insertions, and deletions by ID.
- Maintainability: The code is modular (logic separated from UI), readable,
  and well-documented, making it easy to understand and modify.
- Reliability: Robust error handling and input validation prevent crashes and
  ensure data integrity.
- Usability: The console interface is straightforward and provides clear feedback
  to the user.
"""

import sys
from typing import Dict, List, Any

# For representing the structured task data.
# A simple dictionary is used as per the requirements, but a dataclass or a
# named tuple would also be an excellent choice for more complex scenarios.
TaskDict = Dict[str, Any]


class TaskManager:
    """
    Manages a collection of tasks in memory.

    This class provides the core functionality for a todo list application,
    encapsulating all logic for task manipulation. It uses a dictionary for
    efficient data storage and retrieval.
    """

    def __init__(self) -> None:
        """
        Initializes the TaskManager with an empty task list and an ID counter.
        """
        self._tasks: Dict[int, TaskDict] = {}
        self._next_id: int = 1

    def _validate_id(self, task_id: int) -> None:
        """
        Internal helper to validate a task ID.

        Args:
            task_id: The ID of the task to validate.

        Raises:
            TypeError: If task_id is not an integer.
            ValueError: If task_id is not a positive integer.
            KeyError: If no task with the given ID exists.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")
        if task_id not in self._tasks:
            raise KeyError(f"Task with ID '{task_id}' not found.")

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name/title of the task.
            task_description: A detailed description of the task.

        Returns:
            The unique ID assigned to the new task.

        Raises:
            TypeError: If task_name or task_description are not strings.
            ValueError: If task_name or task_description are empty or whitespace.
        """
        if not all(isinstance(arg, str) for arg in [task_name, task_description]):
            raise TypeError("Task name and description must be strings.")
        if not task_name.strip() or not task_description.strip():
            raise ValueError("Task name and description cannot be empty.")

        task_id = self._next_id
        self._tasks[task_id] = {
            "id": task_id,
            "name": task_name.strip(),
            "description": task_description.strip(),
            "is_finished": False,
        }
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its unique ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed.

        Raises:
            TypeError, ValueError, KeyError: Propagated from _validate_id.
        """
        self._validate_id(task_id)
        del self._tasks[task_id]
        return True

    def search(self, search_term: str) -> List[TaskDict]:
        """
        Searches for tasks containing a specific term in their name or description.

        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of task dictionaries that match the search term.

        Raises:
            TypeError: If search_term is not a string.
            ValueError: If search_term is empty or whitespace.
        """
        if not isinstance(search_term, str):
            raise TypeError("Search term must be a string.")
        if not search_term.strip():
            raise ValueError("Search term cannot be empty.")

        term_lower = search_term.lower().strip()
        return [
            task for task in self._tasks.values()
            if term_lower in task["name"].lower() or term_lower in task["description"].lower()
        ]

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished.

        Raises:
            TypeError, ValueError, KeyError: Propagated from _validate_id.
        """
        self._validate_id(task_id)
        self._tasks[task_id]["is_finished"] = True
        return True

    def get_all(self) -> List[TaskDict]:
        """
        Retrieves all tasks.

        Returns:
            A list of all task dictionaries, sorted by ID.
        """
        # Sorting by ID provides a consistent and predictable order.
        return sorted(self._tasks.values(), key=lambda task: task["id"])

    def clear_all(self) -> bool:
        """
        Removes all tasks from the list.

        Returns:
            True, indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1  # Reset the ID counter
        return True


def print_task(task: TaskDict) -> None:
    """Helper function to format and print a single task."""
    status = "Finished" if task["is_finished"] else "Pending"
    print(f"  ID: {task['id']} | Status: {status}")
    print(f"  Name: {task['name']}")
    print(f"  Description: {task['description']}")
    print("-" * 30)


def main() -> None:
    """
    Main function to run the console-based UI for the Todo List App.
    """
    manager = TaskManager()
    print("--- Console Todo List Application ---")

    # Pre-populate with some data for demonstration
    manager.add("Buy groceries", "Milk, Bread, Cheese, and Eggs")
    manager.add("Finish report", "Complete the Q3 financial report for the meeting.")
    manager.finish(1)

    while True:
        print("\nMenu:")
        print("1. Add Task")
        print("2. Remove Task")
        print("3. Mark Task as Finished")
        print("4. Search Tasks")
        print("5. List All Tasks")
        print("6. Clear All Tasks")
        print("7. Exit")

        choice = input("Enter your choice: ")

        try:
            if choice == '1':
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"Success: Task added with ID: {task_id}")

            elif choice == '2':
                task_id_str = input("Enter task ID to remove: ")
                manager.remove(int(task_id_str))
                print(f"Success: Task with ID '{task_id_str}' removed.")

            elif choice == '3':
                task_id_str = input("Enter task ID to mark as finished: ")
                manager.finish(int(task_id_str))
                print(f"Success: Task with ID '{task_id_str}' marked as finished.")

            elif choice == '4':
                term = input("Enter search term: ")
                results = manager.search(term)
                print(f"\nFound {len(results)} task(s) matching '{term}':")
                if not results:
                    print("No tasks found.")
                else:
                    for task in results:
                        print_task(task)

            elif choice == '5':
                all_tasks = manager.get_all()
                print(f"\nListing all {len(all_tasks)} task(s):")
                if not all_tasks:
                    print("The todo list is empty.")
                else:
                    for task in all_tasks:
                        print_task(task)

            elif choice == '6':
                confirm = input("Are you sure you want to delete all tasks? (y/n): ")
                if confirm.lower() == 'y':
                    manager.clear_all()
                    print("Success: All tasks have been cleared.")
                else:
                    print("Operation cancelled.")

            elif choice == '7':
                print("Exiting application. Goodbye!")
                sys.exit(0)

            else:
                print("Invalid choice. Please enter a number from 1 to 7.")

        except (ValueError, TypeError, KeyError) as e:
            # Gracefully handle all expected errors from the TaskManager
            print(f"Error: {e}")
        except Exception as e:
            # Catch any unexpected errors
            print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    main()
```