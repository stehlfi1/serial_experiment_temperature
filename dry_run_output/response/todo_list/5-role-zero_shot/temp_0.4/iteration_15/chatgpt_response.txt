```python
import sys

class TaskValidationError(ValueError):
    """Exception raised for errors in the input task data."""
    pass


class TaskNotFoundError(KeyError):
    """Exception raised when a task with a specified ID does not exist."""
    pass


class TaskManager:
    """
    A class to manage a todo list with operations to add, remove, search,
    finish, get all, and clear all tasks.

    Tasks are stored in-memory as a dictionary mapping task IDs to task data.
    Each task is represented as a dictionary:
    {
        "id": int,
        "task_name": str,
        "task_description": str,
        "is_finished": bool
    }
    """

    def __init__(self):
        """Initialize the TaskManager with an empty task list and ID counter."""
        self._tasks: dict[int, dict] = {}
        self._next_id: int = 1

    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task with the given name and description.

        Args:
            task_name (str): The name of the task.
            task_description (str): The description of the task.

        Returns:
            int: The unique ID of the new task.

        Raises:
            TaskValidationError: If the task name or description is invalid.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise TaskValidationError("Task name must be a non-empty string.")
        if not isinstance(task_description, str) or not task_description.strip():
            raise TaskValidationError("Task description must be a non-empty string.")

        new_task = {
            "id": self._next_id,
            "task_name": task_name.strip(),
            "task_description": task_description.strip(),
            "is_finished": False
        }
        self._tasks[self._next_id] = new_task
        self._next_id += 1
        return new_task["id"]

    def remove(self, task_id: int) -> bool:
        """
        Remove the task with the given ID.

        Args:
            task_id (int): The unique ID of the task to remove.

        Returns:
            bool: True if the task was removed, False otherwise.

        Raises:
            TaskValidationError: If the task ID is invalid.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise TaskValidationError("Task ID must be a positive integer.")

        if task_id in self._tasks:
            del self._tasks[task_id]
            return True
        return False

    def search(self, task_term: str) -> list[dict]:
        """
        Search for tasks that contain the term in their name or description (case-insensitive).

        Args:
            task_term (str): The term to search for.

        Returns:
            list[dict]: List of tasks matching the search term.

        Raises:
            TaskValidationError: If the search term is invalid.
        """
        if not isinstance(task_term, str) or not task_term.strip():
            raise TaskValidationError("Search term must be a non-empty string.")
        term = task_term.strip().lower()
        results = [
            task.copy()
            for task in self._tasks.values()
            if term in task["task_name"].lower() or term in task["task_description"].lower()
        ]
        return results

    def finish(self, task_id: int) -> bool:
        """
        Mark the given task as finished.

        Args:
            task_id (int): The unique ID of the task to finish.

        Returns:
            bool: True if the operation was successful, False otherwise.

        Raises:
            TaskValidationError: If the task ID is invalid.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise TaskValidationError("Task ID must be a positive integer.")
        if task_id not in self._tasks:
            return False
        self._tasks[task_id]["is_finished"] = True
        return True

    def get_all(self) -> list[dict]:
        """
        Retrieve all tasks.

        Returns:
            list[dict]: List of all tasks with their details.
        """
        return [task.copy() for task in self._tasks.values()]

    def clear_all(self) -> bool:
        """
        Remove all tasks.

        Returns:
            bool: True if tasks were cleared (even if already empty).
        """
        self._tasks.clear()
        return True

    # --- Additional utility for testability ---
    def _reset(self):
        """
        Reset the task manager. For testing and debugging only.
        """
        self._tasks.clear()
        self._next_id = 1


def run_console_app():
    """
    Run the console-based todo list app.
    """
    manager = TaskManager()
    menu = """
    === Todo List Manager ===
    1. Add Task
    2. Remove Task
    3. Search Tasks
    4. Finish Task
    5. List All Tasks
    6. Clear All Tasks
    0. Exit
    =========================
    """

    def print_tasks(tasks):
        if not tasks:
            print("No tasks found.")
            return
        print("\nTasks:")
        for task in tasks:
            status = "âœ”" if task["is_finished"] else " "
            print(f'ID: {task["id"]} | [{status}] {task["task_name"]}: {task["task_description"]}')
        print()

    while True:
        print(menu)
        choice = input("Select an option: ").strip()
        try:
            if choice == "1":
                name = input("Task name: ").strip()
                desc = input("Task description: ").strip()
                task_id = manager.add(name, desc)
                print(f"Task added with ID {task_id}.\n")
            elif choice == "2":
                task_id = int(input("Enter task ID to remove: "))
                if manager.remove(task_id):
                    print("Task removed.\n")
                else:
                    print("Task ID not found.\n")
            elif choice == "3":
                term = input("Enter search term: ").strip()
                results = manager.search(term)
                print_tasks(results)
            elif choice == "4":
                task_id = int(input("Enter task ID to finish: "))
                if manager.finish(task_id):
                    print("Task marked as completed.\n")
                else:
                    print("Task ID not found.\n")
            elif choice == "5":
                print_tasks(manager.get_all())
            elif choice == "6":
                confirm = input("Are you sure you want to clear ALL tasks? (y/N): ").strip().lower()
                if confirm == "y":
                    manager.clear_all()
                    print("All tasks deleted.\n")
                else:
                    print("Operation cancelled.\n")
            elif choice == "0":
                print("Exiting. Goodbye!")
                sys.exit(0)
            else:
                print("Invalid option. Try again.\n")
        except (TaskValidationError, ValueError) as ve:
            print(f"Input error: {ve}\n")
        except Exception as ex:
            print(f"An unexpected error occurred: {ex}\n")


# To run the app, uncomment the following lines:
# if __name__ == "__main__":
#     run_console_app()
```
**Notes**:
- The application is OOP-based, modular, and testable.
- Robust input validation and exception handling are included.
- The task format follows your specification: (id, task_name, task_description, is_finished).
- Each function is clearly documented for easy maintenance.
- Uncomment the block at the end to enable running the console app.