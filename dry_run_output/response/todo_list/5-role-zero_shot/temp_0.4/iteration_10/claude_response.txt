```python
"""
High-quality console-based todo list application following ISO/IEC 25010 standards.

This module provides a TaskManager class for managing todo tasks with full CRUD operations,
validation, and error handling.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Represents a single task in the todo list.
    
    Attributes:
        id: Unique identifier for the task
        task_name: Name/title of the task
        task_description: Detailed description of the task
        is_finished: Completion status of the task
        created_at: Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool = False
    created_at: datetime = None
    
    def __post_init__(self):
        """Set creation timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now()
    
    def to_dict(self) -> Dict:
        """Convert task to dictionary format for external consumption."""
        return {
            'id': self.id,
            'task_name': self.task_name,
            'task_description': self.task_description,
            'is_finished': self.is_finished
        }


class TaskManagerError(Exception):
    """Base exception class for TaskManager-related errors."""
    pass


class InvalidInputError(TaskManagerError):
    """Raised when invalid input is provided to TaskManager methods."""
    pass


class TaskNotFoundError(TaskManagerError):
    """Raised when attempting to operate on a non-existent task."""
    pass


class TaskManager:
    """
    A thread-safe task management system for todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks with proper
    validation and error handling.
    """
    
    def __init__(self):
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a threading lock for thread safety.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety
    
    def _validate_task_name(self, task_name: str) -> None:
        """
        Validate task name input.
        
        Args:
            task_name: The task name to validate
            
        Raises:
            InvalidInputError: If task_name is invalid
        """
        if not isinstance(task_name, str):
            raise InvalidInputError("Task name must be a string")
        if not task_name or not task_name.strip():
            raise InvalidInputError("Task name cannot be empty or whitespace only")
        if len(task_name.strip()) > 200:
            raise InvalidInputError("Task name cannot exceed 200 characters")
    
    def _validate_task_description(self, task_description: str) -> None:
        """
        Validate task description input.
        
        Args:
            task_description: The task description to validate
            
        Raises:
            InvalidInputError: If task_description is invalid
        """
        if not isinstance(task_description, str):
            raise InvalidInputError("Task description must be a string")
        if not task_description or not task_description.strip():
            raise InvalidInputError("Task description cannot be empty or whitespace only")
        if len(task_description.strip()) > 1000:
            raise InvalidInputError("Task description cannot exceed 1000 characters")
    
    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID input.
        
        Args:
            task_id: The task ID to validate
            
        Raises:
            InvalidInputError: If task_id is invalid
            TaskNotFoundError: If task_id doesn't exist
        """
        if not isinstance(task_id, int):
            raise InvalidInputError("Task ID must be an integer")
        if task_id <= 0:
            raise InvalidInputError("Task ID must be a positive integer")
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task with ID {task_id} not found")
    
    def _validate_search_term(self, task_term: str) -> None:
        """
        Validate search term input.
        
        Args:
            task_term: The search term to validate
            
        Raises:
            InvalidInputError: If task_term is invalid
        """
        if not isinstance(task_term, str):
            raise InvalidInputError("Search term must be a string")
        if not task_term or not task_term.strip():
            raise InvalidInputError("Search term cannot be empty or whitespace only")
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name: Name/title of the task
            task_description: Detailed description of the task
            
        Returns:
            int: Unique ID of the created task
            
        Raises:
            InvalidInputError: If inputs are invalid
            
        Time Complexity: O(1)
        """
        self._validate_task_name(task_name)
        self._validate_task_description(task_description)
        
        with self._lock:
            task_id = self._next_id
            self._next_id += 1
            
            task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip()
            )
            
            self._tasks[task_id] = task
            return task_id
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list.
        
        Args:
            task_id: Unique identifier of the task to remove
            
        Returns:
            bool: True if task was successfully removed
            
        Raises:
            InvalidInputError: If task_id is invalid
            TaskNotFoundError: If task doesn't exist
            
        Time Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            del self._tasks[task_id]
            return True
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description.
        
        Args:
            task_term: Search term to match against task names and descriptions
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            InvalidInputError: If task_term is invalid
            
        Time Complexity: O(n) where n is the number of tasks
        """
        self._validate_search_term(task_term)
        
        search_term_lower = task_term.strip().lower()
        matching_tasks = []
        
        with self._lock:
            for task in self._tasks.values():
                if (search_term_lower in task.task_name.lower() or 
                    search_term_lower in task.task_description.lower()):
                    matching_tasks.append(task.to_dict())
        
        # Sort by task ID for consistent ordering
        return sorted(matching_tasks, key=lambda x: x['id'])
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id: Unique identifier of the task to complete
            
        Returns:
            bool: True if task was successfully marked as finished
            
        Raises:
            InvalidInputError: If task_id is invalid
            TaskNotFoundError: If task doesn't exist
            
        Time Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            self._tasks[task_id].is_finished = True
            return True
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks in the todo list.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, sorted by ID
            
        Time Complexity: O(n log n) where n is the number of tasks (due to sorting)
        """
        with self._lock:
            all_tasks = [task.to_dict() for task in self._tasks.values()]
        
        # Sort by task ID for consistent ordering
        return sorted(all_tasks, key=lambda x: x['id'])
    
    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: True if all tasks were successfully cleared
            
        Time Complexity: O(1)
        """
        with self._lock:
            self._tasks.clear()
            self._next_id = 1  # Reset ID counter
            return True
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Number of tasks in the todo list
            
        Time Complexity: O(1)
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
            
        Time Complexity: O(n) where n is the number of tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)


def main():
    """
    Demonstration of the TaskManager functionality.
    
    This function shows basic usage of all TaskManager methods with
    proper error handling.
    """
    try:
        # Initialize task manager
        task_manager = TaskManager()
        
        # Add some sample tasks
        print("Adding tasks...")
        task1_id = task_manager.add("Buy groceries", "Get milk, bread, and eggs from the store")
        task2_id = task_manager.add("Complete project", "Finish the Python todo list application")
        task3_id = task_manager.add("Exercise", "Go for a 30-minute run in the park")
        
        print(f"Added tasks with IDs: {task1_id}, {task2_id}, {task3_id}")
        
        # Display all tasks
        print("\nAll tasks:")
        for task in task_manager.get_all():
            status = "✓" if task['is_finished'] else "○"
            print(f"{status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Mark a task as finished
        print(f"\nMarking task {task1_id} as finished...")
        task_manager.finish(task1_id)
        
        # Search for tasks
        print("\nSearching for 'project':")
        search_results = task_manager.search("project")
        for task in search_results:
            status = "✓" if task['is_finished'] else "○"
            print(f"{status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Display statistics
        print(f"\nTask statistics:")
        print(f"Total tasks: {task_manager.get_task_count()}")
        print(f"Completed tasks: {task_manager.get_completed_count()}")
        
        # Remove a task
        print(f"\nRemoving task {task2_id}...")
        task_manager.remove(task2_id)
        
        print(f"Remaining tasks: {task_manager.get_task_count()}")
        
    except (InvalidInputError, TaskNotFoundError, TaskManagerError) as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")


if __name__ == "__main__":
    main()
```

This implementation provides a comprehensive, high-quality todo list application that adheres to ISO/IEC 25010 standards with the following key features:

## Quality Characteristics Addressed:

1. **Functional Suitability**: All required methods implemented with proper interfaces
2. **Performance Efficiency**: O(1) operations for add/remove/finish, efficient data structures
3. **Compatibility**: Standard Python types and threading support
4. **Usability**: Clear error messages and intuitive method names
5. **Reliability**: Comprehensive error handling and validation
6. **Security**: Input validation and sanitization
7. **Maintainability**: Clean code structure, documentation, and modularity
8. **Portability**: Pure Python implementation with no external dependencies

## Key Features:

- **Thread Safety**: Uses threading locks for concurrent access
- **Comprehensive Validation**: Validates all inputs with appropriate error types
- **Efficient Data Structures**: Dictionary for O(1) lookups
- **Proper Error Handling**: Custom exception hierarchy
- **Documentation**: Extensive docstrings and comments
- **Type Hints**: Full type annotations for better code clarity
- **Testability**: Modular design with clear interfaces
- **Data Integrity**: Immutable task IDs and proper state management

The code is production-ready and follows Python best practices while meeting all specified requirements.