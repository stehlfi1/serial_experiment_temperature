```python
"""
High-quality console-based todo list application following ISO/IEC 25010 standards.

This module provides a TaskManager class for managing todo tasks with full CRUD operations,
input validation, and efficient data handling.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Represents a single task with all its properties.
    
    Attributes:
        id: Unique identifier for the task
        task_name: Name/title of the task
        task_description: Detailed description of the task
        is_finished: Completion status of the task
        created_at: Timestamp when the task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool = False
    created_at: datetime = None
    
    def __post_init__(self):
        """Set creation timestamp if not provided."""
        if self.created_at is None:
            self.created_at = datetime.now()
    
    def to_dict(self) -> Dict:
        """Convert task to dictionary format for external consumption."""
        return {
            'id': self.id,
            'task_name': self.task_name,
            'task_description': self.task_description,
            'is_finished': self.is_finished
        }


class TaskManagerError(Exception):
    """Base exception class for TaskManager-related errors."""
    pass


class InvalidInputError(TaskManagerError):
    """Raised when invalid input is provided."""
    pass


class TaskNotFoundError(TaskManagerError):
    """Raised when a task with specified ID is not found."""
    pass


class TaskManager:
    """
    A thread-safe task management system for todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. All operations
    are optimized for performance and include proper input validation.
    
    Attributes:
        _tasks: Dictionary storing tasks with ID as key for O(1) lookups
        _next_id: Counter for generating unique task IDs
        _lock: Thread lock for ensuring thread safety
    """
    
    def __init__(self):
        """Initialize the TaskManager with empty task storage."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for nested calls
    
    def _validate_task_input(self, task_name: str, task_description: str) -> None:
        """
        Validate task input parameters.
        
        Args:
            task_name: The name of the task
            task_description: The description of the task
            
        Raises:
            InvalidInputError: If inputs are invalid
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise InvalidInputError("Task name must be a non-empty string")
        
        if not isinstance(task_description, str) or not task_description.strip():
            raise InvalidInputError("Task description must be a non-empty string")
    
    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID parameter.
        
        Args:
            task_id: The ID to validate
            
        Raises:
            InvalidInputError: If task_id is invalid
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise InvalidInputError("Task ID must be a positive integer")
    
    def _get_task_by_id(self, task_id: int) -> Task:
        """
        Retrieve a task by its ID.
        
        Args:
            task_id: The ID of the task to retrieve
            
        Returns:
            Task: The task object
            
        Raises:
            TaskNotFoundError: If task with given ID doesn't exist
        """
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task with ID {task_id} not found")
        return self._tasks[task_id]
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name: Name of the task (must be non-empty string)
            task_description: Description of the task (must be non-empty string)
            
        Returns:
            int: Unique ID of the created task
            
        Raises:
            InvalidInputError: If task_name or task_description are invalid
            
        Time Complexity: O(1)
        """
        self._validate_task_input(task_name, task_description)
        
        with self._lock:
            task_id = self._next_id
            self._next_id += 1
            
            # Create and store the task
            task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip()
            )
            self._tasks[task_id] = task
            
            return task_id
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list.
        
        Args:
            task_id: ID of the task to remove (must be positive integer)
            
        Returns:
            bool: True if task was successfully removed, False otherwise
            
        Raises:
            InvalidInputError: If task_id is invalid
            
        Time Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            if task_id in self._tasks:
                del self._tasks[task_id]
                return True
            return False
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description.
        
        Args:
            task_term: Search term to look for in task names and descriptions
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            InvalidInputError: If task_term is invalid
            
        Time Complexity: O(n) where n is the number of tasks
        """
        if not isinstance(task_term, str) or not task_term.strip():
            raise InvalidInputError("Search term must be a non-empty string")
        
        search_term_lower = task_term.strip().lower()
        matching_tasks = []
        
        with self._lock:
            for task in self._tasks.values():
                # Case-insensitive search in both name and description
                if (search_term_lower in task.task_name.lower() or 
                    search_term_lower in task.task_description.lower()):
                    matching_tasks.append(task.to_dict())
        
        # Sort by task ID for consistent ordering
        return sorted(matching_tasks, key=lambda x: x['id'])
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id: ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished, False if not found
            
        Raises:
            InvalidInputError: If task_id is invalid
            
        Time Complexity: O(1)
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            try:
                task = self._get_task_by_id(task_id)
                task.is_finished = True
                return True
            except TaskNotFoundError:
                return False
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks with their details.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, sorted by ID
            
        Time Complexity: O(n log n) where n is the number of tasks (due to sorting)
        """
        with self._lock:
            all_tasks = [task.to_dict() for task in self._tasks.values()]
            # Sort by task ID for consistent ordering
            return sorted(all_tasks, key=lambda x: x['id'])
    
    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: Always returns True indicating successful operation
            
        Time Complexity: O(1)
        """
        with self._lock:
            self._tasks.clear()
            # Reset ID counter for clean state
            self._next_id = 1
            return True
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Number of tasks currently stored
            
        Time Complexity: O(1)
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
            
        Time Complexity: O(n) where n is the number of tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)


def main():
    """
    Demonstration of the TaskManager functionality.
    
    This function shows basic usage patterns and serves as an example
    of how to interact with the TaskManager class.
    """
    # Create a task manager instance
    task_manager = TaskManager()
    
    try:
        # Add some sample tasks
        print("Adding tasks...")
        task1_id = task_manager.add("Buy groceries", "Get milk, bread, and eggs from the store")
        task2_id = task_manager.add("Complete project", "Finish the Python todo list application")
        task3_id = task_manager.add("Exercise", "Go for a 30-minute run in the park")
        
        print(f"Added tasks with IDs: {task1_id}, {task2_id}, {task3_id}")
        
        # Display all tasks
        print("\nAll tasks:")
        for task in task_manager.get_all():
            status = "✓" if task['is_finished'] else "○"
            print(f"{status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Mark a task as finished
        print(f"\nMarking task {task1_id} as finished...")
        task_manager.finish(task1_id)
        
        # Search for tasks
        print("\nSearching for 'project':")
        search_results = task_manager.search("project")
        for task in search_results:
            status = "✓" if task['is_finished'] else "○"
            print(f"{status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Display statistics
        print(f"\nStatistics:")
        print(f"Total tasks: {task_manager.get_task_count()}")
        print(f"Completed tasks: {task_manager.get_completed_count()}")
        
    except (InvalidInputError, TaskNotFoundError, TaskManagerError) as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    main()
```

This implementation provides a comprehensive, high-quality todo list application that adheres to ISO/IEC 25010 standards. Here are the key features:

## Quality Characteristics Addressed:

**1. Functional Suitability:**
- Complete implementation of all required interface methods
- Proper input validation and error handling
- Consistent return formats

**2. Performance Efficiency:**
- O(1) operations for add, remove, finish, and clear_all
- Efficient dictionary-based storage for fast lookups
- Optimized search with case-insensitive matching

**3. Compatibility:**
- Uses standard Python libraries only
- Compatible with Python 3.7+
- Thread-safe implementation

**4. Usability:**
- Clear, descriptive method names and docstrings
- Comprehensive error messages
- Intuitive API design

**5. Reliability:**
- Robust error handling with custom exception classes
- Input validation for all methods
- Thread-safe operations with proper locking

**6. Security:**
- Protection against invalid inputs
- Safe data handling practices
- No external dependencies that could introduce vulnerabilities

**7. Maintainability:**
- Clean, modular code structure
- Comprehensive documentation
- Separation of concerns with dedicated validation methods
- Easy to extend and modify

**8. Portability:**
- Pure Python implementation
- No platform-specific dependencies
- Standard library usage only

The code includes proper type hints, comprehensive error handling, thread safety, and follows Python best practices for maintainable, production-ready software.