Of course. As a senior software developer, I will provide a high-quality Python implementation for the console-based todo list application. The solution will adhere to your specified requirements, focusing on the principles of the ISO/IEC 25010 standard, such as correctness, performance, modularity, safety, and readability.

The code is structured using Object-Oriented Programming (OOP) with a `TaskManager` class. A `dataclass` is used for the `Task` entity to ensure data integrity and readability. The primary data structure for storage is a dictionary, which provides efficient O(1) average time complexity for lookups, insertions, and deletions by ID.

Here is the complete, documented, and maintainable Python code.

```python
"""
A high-quality, maintainable implementation of a console-based Todo List application.

This module provides a TaskManager class that adheres to the ISO/IEC 25010 standard
for software quality, focusing on:
- Functional Suitability: Implements all required functionalities (add, remove, etc.).
- Performance Efficiency: Uses efficient data structures (dictionaries) for fast operations.
- Maintainability: Code is modular, readable, and well-documented.
- Reliability: Includes robust error handling and input validation.
- Usability: Provides a clear and consistent interface.
- Security: Protects against invalid inputs.
"""

import sys
from dataclasses import dataclass
from typing import Dict, List, Union

# Define a type alias for the dictionary representation of a task for clarity.
TaskDict = Dict[str, Union[int, str, bool]]


@dataclass
class Task:
    """
    Represents a single task in the todo list.

    Using a dataclass provides a robust, readable, and type-safe way to
    handle task data, including automatic __init__, __repr__, and __eq__ methods.
    """
    id: int
    name: str
    description: str
    is_finished: bool = False


class TaskManager:
    """
    Manages a collection of tasks in memory.

    This class provides a complete interface for adding, removing, searching,
    and modifying tasks, ensuring data integrity and efficient operations.
    """

    def __init__(self) -> None:
        """
        Initializes the TaskManager.

        Internal storage `_tasks` is a dictionary for O(1) average time
        complexity for ID-based lookups, insertions, and deletions.
        `_next_id` ensures that every task gets a unique ID.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1

    def _validate_string_input(self, input_name: str, value: str) -> None:
        """
        Private helper to validate that string inputs are non-empty.

        Args:
            input_name: The name of the parameter being validated (e.g., 'task_name').
            value: The string value to validate.

        Raises:
            TypeError: If the value is not a string.
            ValueError: If the value is an empty or whitespace-only string.
        """
        if not isinstance(value, str):
            raise TypeError(f"{input_name} must be a string.")
        if not value.strip():
            raise ValueError(f"{input_name} cannot be empty or just whitespace.")

    def _get_task_by_id(self, task_id: int) -> Task:
        """
        Private helper to retrieve a task by its ID, with validation.

        Args:
            task_id: The unique identifier of the task.

        Returns:
            The Task object if found.

        Raises:
            TypeError: If task_id is not an integer.
            ValueError: If task_id is not a positive integer.
            KeyError: If no task with the given ID exists.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")
        if task_id not in self._tasks:
            raise KeyError(f"Task with ID {task_id} not found.")
        return self._tasks[task_id]
    
    def _format_task_as_dict(self, task: Task) -> TaskDict:
        """
        Private helper to convert a Task object to the specified dictionary format.
        
        This promotes consistency and adheres to the Don't Repeat Yourself (DRY) principle.

        Args:
            task: The Task object to format.

        Returns:
            A dictionary representation of the task.
        """
        return {
            "id": task.id,
            "task_name": task.name,
            "task_description": task.description,
            "is_finished": task.is_finished,
        }

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name of the task. Cannot be empty.
            task_description: A detailed description of the task. Cannot be empty.

        Returns:
            The unique ID assigned to the newly created task.

        Raises:
            TypeError: If task_name or task_description are not strings.
            ValueError: If task_name or task_description are empty or whitespace.
        """
        self._validate_string_input("task_name", task_name)
        self._validate_string_input("task_description", task_description)

        task_id = self._next_id
        new_task = Task(id=task_id, name=task_name.strip(), description=task_description.strip())
        self._tasks[task_id] = new_task
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task from the list by its ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed, False otherwise (e.g., ID not found).
        """
        try:
            self._get_task_by_id(task_id)  # Validate existence and input type
            del self._tasks[task_id]
            return True
        except (TypeError, ValueError, KeyError):
            # Gracefully handle invalid IDs or non-existent tasks
            return False

    def search(self, search_term: str) -> List[TaskDict]:
        """
        Searches for tasks where the search term appears in the name or description.
        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of task dictionaries that match the search criteria.
            Returns an empty list if no matches are found or the search term is empty.
            
        Raises:
            TypeError: If search_term is not a string.
        """
        if not isinstance(search_term, str):
            raise TypeError("Search term must be a string.")
            
        if not search_term.strip():
            return []

        normalized_term = search_term.lower()
        results = [
            self._format_task_as_dict(task)
            for task in self._tasks.values()
            if normalized_term in task.name.lower() or normalized_term in task.description.lower()
        ]
        return results

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as completed.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished, False otherwise.
        """
        try:
            task = self._get_task_by_id(task_id)
            task.is_finished = True
            return True
        except (TypeError, ValueError, KeyError):
            return False

    def get_all(self) -> List[TaskDict]:
        """
        Retrieves all tasks currently in the list.

        Returns:
            A list of all task dictionaries. The list is sorted by task ID.
        """
        sorted_tasks = sorted(self._tasks.values(), key=lambda t: t.id)
        return [self._format_task_as_dict(task) for task in sorted_tasks]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the list and resets the ID counter.

        Returns:
            True, indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1
        return True


# --- Demonstration of Usage ---
if __name__ == "__main__":
    # This block demonstrates how to use the TaskManager class.
    # It also serves as a basic, informal test suite.
    
    def print_tasks(tasks: List[TaskDict], title: str):
        """Helper function to pretty-print a list of tasks."""
        print(f"--- {title} ---")
        if not tasks:
            print("No tasks to show.")
        for task in tasks:
            status = "✓" if task['is_finished'] else "✗"
            print(f"[{status}] ID: {task['id']}, Name: {task['task_name']}, Desc: {task['task_description']}")
        print("-" * (len(title) + 6) + "\n")

    manager = TaskManager()

    print("--- Initializing Todo List ---\n")

    # 1. Add tasks
    print("1. Adding tasks...")
    try:
        id1 = manager.add("Buy groceries", "Milk, Bread, Cheese")
        id2 = manager.add("Learn Python", "Study OOP and best practices.")
        id3 = manager.add("Clean the house", "Vacuum and dust all rooms.")
        print(f"Added tasks with IDs: {id1}, {id2}, {id3}")
    except (ValueError, TypeError) as e:
        print(f"Error adding task: {e}", file=sys.stderr)
    
    # Demonstrate adding an invalid task
    try:
        manager.add("  ", "Invalid task")
    except ValueError as e:
        print(f"Correctly caught an error: {e}")
    print("\n")

    # 2. Get all tasks
    all_tasks = manager.get_all()
    print_tasks(all_tasks, "All Tasks After Adding")

    # 3. Finish a task
    print("3. Finishing task with ID 2...")
    success = manager.finish(2)
    print(f"Operation successful: {success}")
    
    # Try to finish a non-existent task
    success_fail = manager.finish(99)
    print("   Finishing task with ID 99...")
    print(f"Operation successful: {success_fail}\n")

    print_tasks(manager.get_all(), "Tasks After Finishing One")

    # 4. Search for tasks
    print("4. Searching for tasks with the term 'python'...")
    search_results = manager.search("python")
    print_tasks(search_results, "Search Results for 'python'")

    # 5. Remove a task
    print("5. Removing task with ID 1...")
    removed = manager.remove(1)
    print(f"Operation successful: {removed}\n")

    print_tasks(manager.get_all(), "Tasks After Removing One")

    # 6. Clear all tasks
    print("6. Clearing all tasks...")
    cleared = manager.clear_all()
    print(f"Operation successful: {cleared}\n")

    print_tasks(manager.get_all(), "All Tasks After Clearing")

```