```python
"""
A console-based Todo List App conforming to ISO/IEC 25010 quality standards.
Implements a TaskManager class supporting core todo functionalities
with a focus on correctness, efficiency, maintainability, and usability.

Author: (Your Name)
Date: 2024-06-10
"""

from typing import List, Dict, Optional

class TaskNotFoundError(ValueError):
    """Custom error raised when a task ID is not found."""

class InvalidTaskInputError(ValueError):
    """Custom error raised when task input is invalid."""

class TaskManager:
    """
    Manages a collection of todo tasks in-memory,
    providing CRUD and search functionalities.
    """

    def __init__(self):
        """
        Initializes an empty TaskManager.
        """
        self._tasks: Dict[int, Dict] = {}  # Task storage: {id: {task_data}}
        self._next_id: int = 1             # Unique, incrementing task ID

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task.

        Args:
            task_name (str): Description/title of the task (non-empty).
            task_description (str): Additional task details (non-empty).

        Returns:
            int: The unique ID of the created task.

        Raises:
            InvalidTaskInputError: If task_name or task_description are empty.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise InvalidTaskInputError("Task name cannot be empty.")
        if not isinstance(task_description, str) or not task_description.strip():
            raise InvalidTaskInputError("Task description cannot be empty.")

        task_id = self._next_id
        self._tasks[task_id] = {
            'id': task_id,
            'task_name': task_name.strip(),
            'task_description': task_description.strip(),
            'is_finished': False
        }
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its unique ID.

        Args:
            task_id (int): Unique identifier for the task (must be positive).

        Returns:
            bool: True if task was removed, False otherwise.

        Raises:
            ValueError: If task_id is not a valid integer or negative.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")
        return self._tasks.pop(task_id, None) is not None

    def search(self, task_term: str) -> List[Dict]:
        """
        Searches tasks by name or description containing the search term.

        Args:
            task_term (str): Term to search for (non-empty).

        Returns:
            List[Dict]: List of matching task dictionaries.

        Raises:
            ValueError: If task_term is empty or not a string.
        """
        if not isinstance(task_term, str) or not task_term.strip():
            raise ValueError("Search term must be a non-empty string.")
        term = task_term.strip().lower()
        results = []
        for task in self._tasks.values():
            if (term in task['task_name'].lower()) or (term in task['task_description'].lower()):
                # Return a copy to prevent accidental modification
                results.append(task.copy())
        return results

    def finish(self, task_id: int) -> bool:
        """
        Marks the specified task as completed.

        Args:
            task_id (int): Unique identifier for the task (must be positive).

        Returns:
            bool: True if task was marked as finished, False if not found.

        Raises:
            ValueError: If task_id is not a valid integer or negative.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")

        task = self._tasks.get(task_id)
        if not task:
            return False
        if not task['is_finished']:
            task['is_finished'] = True
        return True

    def get_all(self) -> List[Dict]:
        """
        Retrieves all tasks in the todo list.

        Returns:
            List[Dict]: List of tasks, each as (id, task_name, task_description, is_finished).
        """
        return [task.copy() for task in sorted(self._tasks.values(), key=lambda x: x['id'])]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the todo list.

        Returns:
            bool: True if tasks were cleared (even if list was already empty).
        """
        self._tasks.clear()
        return True


# -------------------------
# Example Console Interface
# -------------------------

def print_task(task: Dict):
    """
    Neatly prints a task dictionary.
    """
    print(f"[{'X' if task['is_finished'] else ' '}] "
          f"ID: {task['id']}, Name: {task['task_name']} -- {task['task_description']}")

def demo():
    """
    Demonstrates usage of TaskManager functionality via console.
    """
    print("=== TaskManager Demo ===")
    manager = TaskManager()

    try:
        # Add some tasks
        print("\nAdding tasks...")
        id1 = manager.add("Buy groceries", "Milk, eggs, bread")
        id2 = manager.add("Read book", "Read chapter 6 of Python book")
        print(f"Added tasks with IDs: {id1}, {id2}")

        # Display all tasks
        print("\nAll tasks:")
        for task in manager.get_all():
            print_task(task)

        # Search for a task
        print("\nSearching for 'python':")
        search_results = manager.search("python")
        for task in search_results:
            print_task(task)

        # Finish a task
        print("\nMarking task as finished (ID 2):")
        if manager.finish(2):
            print("Task marked as finished.")
        else:
            print("Task not found.")
        print("\nAll tasks after finishing one:")
        for task in manager.get_all():
            print_task(task)

        # Remove a task
        print("\nRemoving task with ID 1:")
        if manager.remove(1):
            print("Task removed.")
        else:
            print("Task not found.")

        print("\nAll tasks after removal:")
        for task in manager.get_all():
            print_task(task)

        # Clear all tasks
        print("\nClearing all tasks...")
        manager.clear_all()
        print("All tasks cleared!")
        print("\nAll tasks now:")
        if not manager.get_all():
            print("(No tasks)")
    except (InvalidTaskInputError, ValueError) as e:
        print(f"Input Error: {e}")

if __name__ == "__main__":
    demo()

```
**Key points on ISO/IEC 25010 requirements:**
- **Correctness**: All actions validated, state consistent, clear error handling.
- **Performance**: Dictionary-based ID lookup/insert/remove â€” O(1) complexity.
- **Modularity**: Separation of task manager logic and console interface.
- **Safety**: Input validation, no mutation of internal state from outside.
- **Testability**: Well-defined class methods and exceptions.
- **Readability/Documentation**: Rich docstrings and comments.
- **Maintainability**: Extensible structure, minimal coupling.

This code is ready for extension, integration, or use as a self-contained console application, maintaining high quality and clarity.