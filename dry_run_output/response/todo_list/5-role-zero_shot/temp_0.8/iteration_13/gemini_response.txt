Of course. As a senior software developer, I understand the importance of creating code that is not only functional but also robust, maintainable, and efficient, aligning with the principles of the ISO/IEC 25010 standard.

Here is a high-quality Python implementation of a console-based todo list application that meets all your specified requirements.

### Explanation of Design Choices (Adherence to ISO/IEC 25010)

*   **Functional Suitability (Correctness & Completeness):** The `TaskManager` class correctly implements all required functionalities (`add`, `remove`, etc.). It behaves predictably and completely covers the specified functional requirements.
*   **Performance Efficiency (Time Behaviour):** The core data structure is a dictionary (`self._tasks`). This allows for `O(1)` (constant time) complexity for a majority of operations like adding, removing, finishing, and retrieving a task by its ID. Searching is`O(n)`, which is optimal for the requirements.
*   **Maintainability (Modularity, Reusability, Testability):**
    *   **Modularity:** The business logic is fully encapsulated within the `TaskManager` class, completely separate from the user interface (the `main` function). This means you could swap the console UI for a web API or a GUI without changing the core `TaskManager` logic.
    *   **Reusability:** The `TaskManager` class can be imported and reused in any other Python application.
    *   **Testability:** The class does not depend on global state or external I/O (like `print` or `input`). It can be easily instantiated and tested in an automated testing framework (e.g., pytest) by checking its return values or the exceptions it raises.
*   **Reliability (Fault Tolerance & Recoverability):**
    *   **Fault Tolerance:** The code uses strict input validation and raises specific, built-in exceptions (`ValueError`, `KeyError`) for foreseeable issues like invalid IDs, empty inputs, or non-existent tasks. This prevents the application from entering an invalid state.
    *   The user interface part in `main()` gracefully catches these exceptions and provides clear, user-friendly error messages, ensuring the application doesn't crash.
*   **Usability (for the Developer) & Portability:**
    *   **Readability & Documentation:** The code is documented with clear docstrings, type hints, and descriptive variable names, making it easy for other developers to understand, use, and maintain.
    *   **Portability:** The code uses only Python's standard library, making it highly portable across any system with a Python 3.7+ interpreter.

---

### The Code

```python
"""
A module for managing a collection of tasks in memory.

This module provides the TaskManager class, which offers a clean, robust,
and efficient interface for a todo list application, following OOP principles
and best practices for maintainable software.
"""

from typing import List, Dict, Any

# Define a type alias for a Task dictionary for better readability and maintenance.
TaskDict = Dict[str, Any]

class TaskManager:
    """
    Manages a collection of tasks in-memory.

    This class encapsulates all the logic for adding, removing, searching,
    and modifying tasks. It is designed for correctness, efficiency, and
    testability.

    Attributes:
        _tasks (dict[int, dict]): A private dictionary to store tasks.
            The key is the task ID, and the value is a dictionary
            containing task details ('task_name', 'task_description', 'is_finished').
        _last_id (int): A private counter to generate unique task IDs.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an empty task list."""
        self._tasks: Dict[int, Dict[str, Any]] = {}
        self._last_id: int = 0

    def _validate_task_id(self, task_id: int) -> None:
        """
        Private helper to validate a task ID.

        Args:
            task_id: The ID to validate.

        Raises:
            ValueError: If task_id is not a positive integer.
            KeyError: If task_id does not exist in the task list.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")
        if task_id not in self._tasks:
            raise KeyError(f"Task with ID {task_id} not found.")

    def _format_task_output(self, task_id: int) -> TaskDict:
        """
        Private helper to format a task into the public-facing dictionary structure.

        Args:
            task_id: The ID of the task to format.

        Returns:
            A dictionary representing the task.
        """
        task_data = self._tasks[task_id]
        return {
            "id": task_id,
            "task_name": task_data["task_name"],
            "task_description": task_data["task_description"],
            "is_finished": task_data["is_finished"],
        }

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name of the task. Must be a non-empty string.
            task_description: A detailed description of the task.

        Returns:
            The unique ID of the newly created task.

        Raises:
            ValueError: If task_name is an empty string.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise ValueError("Task name cannot be empty.")
        if not isinstance(task_description, str):
            # Ensure description is a string, even if empty.
            task_description = ""

        self._last_id += 1
        new_task_id = self._last_id
        self._tasks[new_task_id] = {
            "task_name": task_name.strip(),
            "task_description": task_description.strip(),
            "is_finished": False,
        }
        return new_task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed.

        Raises:
            ValueError: If task_id is not a positive integer.
            KeyError: If no task with the given ID is found.
        """
        self._validate_task_id(task_id)
        del self._tasks[task_id]
        return True

    def search(self, search_term: str) -> List[TaskDict]:
        """
        Searches for tasks by a search term in their name or description.
        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of task dictionaries that match the search term.

        Raises:
            ValueError: If search_term is an empty string.
        """
        if not isinstance(search_term, str) or not search_term.strip():
            raise ValueError("Search term cannot be empty.")

        term_lower = search_term.lower()
        results = []
        for task_id, task_data in self._tasks.items():
            if (term_lower in task_data["task_name"].lower() or
                term_lower in task_data["task_description"].lower()):
                results.append(self._format_task_output(task_id))
        return results

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished.

        Raises:
            ValueError: If task_id is not a positive integer.
            KeyError: If no task with the given ID is found.
        """
        self._validate_task_id(task_id)
        self._tasks[task_id]["is_finished"] = True
        return True

    def get_all(self) -> List[TaskDict]:
        """
        Retrieves all tasks.

        Returns:
            A list of all task dictionaries.
        """
        return [self._format_task_output(task_id) for task_id in self._tasks]

    def clear_all(self) -> bool:
        """
        Deletes all tasks.

        Returns:
            True, confirming all tasks have been cleared.
        """
        self._tasks.clear()
        self._last_id = 0
        return True


# --- Console User Interface (Example of usage) ---

def print_tasks(tasks: List[TaskDict]) -> None:
    """Helper function to print a list of tasks to the console."""
    if not tasks:
        print("\nNo tasks found.")
        return

    print("\n--- Tasks ---")
    for task in tasks:
        status = "Finished" if task["is_finished"] else "Pending"
        print(
            f"ID: {task['id']} | Name: {task['task_name']} | "
            f"Description: {task['task_description']} | Status: {status}"
        )
    print("-------------")


def main() -> None:
    """Main function to run the console-based todo list application."""
    manager = TaskManager()
    print("Welcome to the Console Todo List App!")

    # Pre-populate with some tasks for demonstration
    manager.add("Buy groceries", "Milk, Bread, Cheese")
    manager.add("Finish report", "Complete the Q3 financial report for review.")
    manager.add("Call the doctor", "Schedule a check-up for next week.")

    while True:
        print("\nMenu:")
        print("1. Add Task")
        print("2. List All Tasks")
        print("3. Finish Task")
        print("4. Remove Task")
        print("5. Search Tasks")
        print("6. Clear All Tasks")
        print("7. Exit")

        choice = input("Enter your choice: ")

        try:
            if choice == "1":
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"Success: Task added with ID {task_id}.")
            elif choice == "2":
                all_tasks = manager.get_all()
                print_tasks(all_tasks)
            elif choice == "3":
                task_id_str = input("Enter the ID of the task to finish: ")
                task_id = int(task_id_str)
                if manager.finish(task_id):
                    print(f"Success: Task {task_id} marked as finished.")
            elif choice == "4":
                task_id_str = input("Enter the ID of the task to remove: ")
                task_id = int(task_id_str)
                if manager.remove(task_id):
                    print(f"Success: Task {task_id} has been removed.")
            elif choice == "5":
                term = input("Enter search term: ")
                found_tasks = manager.search(term)
                print(f"Found {len(found_tasks)} task(s) matching '{term}':")
                print_tasks(found_tasks)
            elif choice == "6":
                confirm = input("Are you sure you want to delete all tasks? (y/n): ")
                if confirm.lower() == 'y':
                    manager.clear_all()
                    print("Success: All tasks have been cleared.")
                else:
                    print("Operation cancelled.")
            elif choice == "7":
                print("Exiting application. Goodbye!")
                break
            else:
                print("Invalid choice. Please enter a number from 1 to 7.")

        except (ValueError, KeyError) as e:
            # Gracefully handle validation and logic errors from the manager
            print(f"Error: {e}")
        except Exception as e:
            # Catch any other unexpected errors
            print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    main()
```