```python
"""
High-quality Todo List Application

This module implements a console-based todo list application following ISO/IEC 25010 
quality standards with focus on functionality, reliability, usability, efficiency, 
maintainability, and portability.
"""

from typing import Dict, List, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Represents a single task in the todo list.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime


class TaskManagerError(Exception):
    """Base exception class for TaskManager operations."""
    pass


class TaskNotFoundError(TaskManagerError):
    """Raised when a task with specified ID is not found."""
    pass


class InvalidInputError(TaskManagerError):
    """Raised when invalid input is provided to TaskManager methods."""
    pass


class TaskManager:
    """
    A thread-safe task management system for todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. It implements
    efficient data structures and proper error handling to ensure reliability
    and performance.
    """
    
    def __init__(self) -> None:
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a threading lock for thread safety.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety
    
    def _validate_task_name(self, task_name: str) -> None:
        """
        Validate task name input.
        
        Args:
            task_name (str): The task name to validate
            
        Raises:
            InvalidInputError: If task_name is invalid
        """
        if not isinstance(task_name, str):
            raise InvalidInputError("Task name must be a string")
        if not task_name or not task_name.strip():
            raise InvalidInputError("Task name cannot be empty or whitespace only")
        if len(task_name.strip()) > 100:
            raise InvalidInputError("Task name cannot exceed 100 characters")
    
    def _validate_task_description(self, task_description: str) -> None:
        """
        Validate task description input.
        
        Args:
            task_description (str): The task description to validate
            
        Raises:
            InvalidInputError: If task_description is invalid
        """
        if not isinstance(task_description, str):
            raise InvalidInputError("Task description must be a string")
        if len(task_description.strip()) > 500:
            raise InvalidInputError("Task description cannot exceed 500 characters")
    
    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID input.
        
        Args:
            task_id (int): The task ID to validate
            
        Raises:
            InvalidInputError: If task_id is invalid
        """
        if not isinstance(task_id, int):
            raise InvalidInputError("Task ID must be an integer")
        if task_id <= 0:
            raise InvalidInputError("Task ID must be a positive integer")
    
    def _validate_search_term(self, task_term: str) -> None:
        """
        Validate search term input.
        
        Args:
            task_term (str): The search term to validate
            
        Raises:
            InvalidInputError: If task_term is invalid
        """
        if not isinstance(task_term, str):
            raise InvalidInputError("Search term must be a string")
        if not task_term or not task_term.strip():
            raise InvalidInputError("Search term cannot be empty or whitespace only")
    
    def _task_to_dict(self, task: Task) -> Dict:
        """
        Convert a Task object to dictionary format for external consumption.
        
        Args:
            task (Task): The task to convert
            
        Returns:
            dict: Task data in the required format
        """
        return {
            'id': task.id,
            'task_name': task.task_name,
            'task_description': task.task_description,
            'is_finished': task.is_finished
        }
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): Name of the task (1-100 characters, non-empty)
            task_description (str): Description of the task (max 500 characters)
            
        Returns:
            int: Unique ID of the created task
            
        Raises:
            InvalidInputError: If input validation fails
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        try:
            self._validate_task_name(task_name)
            self._validate_task_description(task_description)
            
            with self._lock:
                task_id = self._next_id
                self._next_id += 1
                
                task = Task(
                    id=task_id,
                    task_name=task_name.strip(),
                    task_description=task_description.strip(),
                    is_finished=False,
                    created_at=datetime.now()
                )
                
                self._tasks[task_id] = task
                return task_id
                
        except Exception as e:
            if isinstance(e, TaskManagerError):
                raise
            raise TaskManagerError(f"Unexpected error adding task: {str(e)}")
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list.
        
        Args:
            task_id (int): ID of the task to remove
            
        Returns:
            bool: True if task was successfully removed, False if task not found
            
        Raises:
            InvalidInputError: If task_id validation fails
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        try:
            self._validate_task_id(task_id)
            
            with self._lock:
                if task_id in self._tasks:
                    del self._tasks[task_id]
                    return True
                return False
                
        except Exception as e:
            if isinstance(e, TaskManagerError):
                raise
            raise TaskManagerError(f"Unexpected error removing task: {str(e)}")
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description.
        
        Args:
            task_term (str): Search term to match against task names and descriptions
            
        Returns:
            list[dict]: List of matching tasks in dictionary format
            
        Raises:
            InvalidInputError: If task_term validation fails
            
        Time Complexity: O(n) where n is the number of tasks
        Space Complexity: O(k) where k is the number of matching tasks
        """
        try:
            self._validate_search_term(task_term)
            
            search_term_lower = task_term.strip().lower()
            matching_tasks = []
            
            with self._lock:
                for task in self._tasks.values():
                    if (search_term_lower in task.task_name.lower() or 
                        search_term_lower in task.task_description.lower()):
                        matching_tasks.append(self._task_to_dict(task))
            
            # Sort by task ID for consistent ordering
            matching_tasks.sort(key=lambda x: x['id'])
            return matching_tasks
            
        except Exception as e:
            if isinstance(e, TaskManagerError):
                raise
            raise TaskManagerError(f"Unexpected error searching tasks: {str(e)}")
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished
            
        Raises:
            InvalidInputError: If task_id validation fails
            TaskNotFoundError: If task with given ID doesn't exist
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        try:
            self._validate_task_id(task_id)
            
            with self._lock:
                if task_id not in self._tasks:
                    raise TaskNotFoundError(f"Task with ID {task_id} not found")
                
                self._tasks[task_id].is_finished = True
                return True
                
        except Exception as e:
            if isinstance(e, TaskManagerError):
                raise
            raise TaskManagerError(f"Unexpected error finishing task: {str(e)}")
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks in the todo list.
        
        Returns:
            list[dict]: List of all tasks in dictionary format, sorted by ID
            
        Time Complexity: O(n log n) where n is the number of tasks (due to sorting)
        Space Complexity: O(n) where n is the number of tasks
        """
        try:
            with self._lock:
                all_tasks = [self._task_to_dict(task) for task in self._tasks.values()]
            
            # Sort by task ID for consistent ordering
            all_tasks.sort(key=lambda x: x['id'])
            return all_tasks
            
        except Exception as e:
            raise TaskManagerError(f"Unexpected error retrieving all tasks: {str(e)}")
    
    def clear_all(self) -> bool:
        """
        Remove all tasks from the todo list.
        
        Returns:
            bool: True if all tasks were successfully cleared
            
        Time Complexity: O(1)
        Space Complexity: O(1)
        """
        try:
            with self._lock:
                self._tasks.clear()
                self._next_id = 1
                return True
                
        except Exception as e:
            raise TaskManagerError(f"Unexpected error clearing all tasks: {str(e)}")
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Total number of tasks in the system
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)


def main():
    """
    Console interface for the Todo List application.
    
    Provides a simple command-line interface for interacting with the TaskManager.
    """
    task_manager = TaskManager()
    
    print("=== Todo List Application ===")
    print("Commands: add, remove, search, finish, list, clear, quit")
    
    while True:
        try:
            command = input("\nEnter command: ").strip().lower()
            
            if command == "quit" or command == "exit":
                print("Goodbye!")
                break
            elif command == "add":
                name = input("Task name: ").strip()
                description = input("Task description: ").strip()
                task_id = task_manager.add(name, description)
                print(f"Task added successfully with ID: {task_id}")
            
            elif command == "remove":
                try:
                    task_id = int(input("Task ID to remove: "))
                    if task_manager.remove(task_id):
                        print("Task removed successfully")
                    else:
                        print("Task not found")
                except ValueError:
                    print("Please enter a valid task ID")
            
            elif command == "search":
                term = input("Search term: ").strip()
                results = task_manager.search(term)
                if results:
                    print(f"\nFound {len(results)} matching task(s):")
                    for task in results:
                        status = "✓" if task['is_finished'] else "○"
                        print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
                else:
                    print("No matching tasks found")
            
            elif command == "finish":
                try:
                    task_id = int(input("Task ID to finish: "))
                    task_manager.finish(task_id)
                    print("Task marked as finished")
                except ValueError:
                    print("Please enter a valid task ID")
                except TaskNotFoundError:
                    print("Task not found")
            
            elif command == "list":
                tasks = task_manager.get_all()
                if tasks:
                    print(f"\nAll tasks ({len(tasks)} total):")
                    for task in tasks:
                        status = "✓" if task['is_finished'] else "○"
                        print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
                else:
                    print("No tasks found")
            
            elif command == "clear":
                confirm = input("Are you sure you want to delete all tasks? (yes/no): ")
                if confirm.lower() == "yes":
                    task_manager.clear_all()
                    print("All tasks cleared")
                else:
                    print("Clear operation cancelled")
            
            elif command == "help":
                print("\nAvailable commands:")
                print("  add    - Add a new task")
                print("  remove - Remove a task by ID")
                print("  search - Search tasks by name or description")
                print("  finish - Mark a task as completed")
                print("  list   - Show all tasks")
                print("  clear  - Delete all tasks")
                print("  quit   - Exit the application")
            
            else:
                print("Unknown command. Type 'help' for available commands.")
                
        except TaskManagerError as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Unexpected error: {e}")


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality, maintainable Todo List application that adheres to ISO/IEC 25010 standards:

## Key Quality Characteristics:

**Functional Suitability:**
- Implements all required methods with correct signatures
- Provides comprehensive task management functionality
- Includes proper data validation and error handling

**Performance Efficiency:**
- Uses dictionary for O(1) task lookups, insertions, and deletions
- Efficient search implementation with O(n) complexity
- Optimized memory usage with appropriate data structures

**Compatibility & Portability:**
- Pure Python implementation with no external dependencies
- Compatible with Python 3.7+
- Cross-platform console interface

**Usability:**
- Clear, intuitive command-line interface
- Helpful error messages and user feedback
- Comprehensive help system

**Reliability:**
- Thread-safe implementation using RLock
- Comprehensive input validation
- Custom exception hierarchy for proper error handling
- Defensive programming practices

**Security:**
- Input validation prevents injection attacks
- Bounds checking for string lengths
- Type checking for all parameters

**Maintainability:**
- Clean OOP design with single responsibility principle
- Comprehensive docstrings and comments
- Modular code structure
- Easy to extend and modify

**Testability:**
- Clear separation of concerns
- Public methods with well-defined contracts
- Predictable behavior and error handling
- Easy to mock and unit test

The code follows Python best practices including PEP 8 style guidelines, proper type hints, and comprehensive documentation.