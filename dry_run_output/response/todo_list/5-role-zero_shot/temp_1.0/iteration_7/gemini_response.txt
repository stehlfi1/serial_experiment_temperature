Of course. As a senior software developer, I will create a high-quality, maintainable, and well-documented Python implementation for a console-based To-Do list application.

This solution adheres to the ISO/IEC 25010 standard by focusing on:
*   **Functional Suitability:** The code correctly implements all specified features.
*   **Performance Efficiency:** It uses a dictionary for data storage, enabling O(1) average time complexity for time-critical operations like adding, removing, and updating tasks by ID.
*   **Maintainability & Modularity:** The logic is encapsulated within a `TaskManager` class, with a separate `Task` data class and a clear separation between core logic and the user interface. Private helper methods are used to avoid code duplication.
*   **Reliability & Safety:** The code includes robust validation and custom, specific exceptions to handle invalid inputs and non-existent data gracefully.
*   **Readability & Testability:** The code is documented with type hints and docstrings, making it easy to understand, use, and write unit tests for.

Here is the complete solution:

```python
"""
A high-quality, maintainable console-based To-Do list application.

This module provides the core logic for managing tasks (TaskManager class)
and a simple command-line interface (CLI) for user interaction.
"""
from __future__ import annotations
import dataclasses
from typing import List, Dict, Any

# --- Custom Exceptions for Clearer Error Handling ---

class TaskError(Exception):
    """Base exception for errors related to tasks."""
    pass

class TaskNotFoundError(TaskError):
    """Raised when a task with a specific ID is not found."""
    pass

class InvalidTaskDataError(TaskError, ValueError):
    """Raised when provided task data (e.g., name) is invalid."""
    pass


# --- Data Model for a Task ---

@dataclasses.dataclass
class Task:
    """
    A dataclass representing a single task.

    Using a dataclass provides type hints, automatic __init__ and __repr__,
    and improves overall code readability and maintainability.
    """
    id: int
    name: str
    description: str
    is_finished: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Converts the task instance to a dictionary."""
        return dataclasses.asdict(self)


# --- Core Application Logic ---

class TaskManager:
    """
    Manages all operations for a collection of tasks.

    This class encapsulates the core business logic, adhering to the principles
    of Object-Oriented Programming. It uses a dictionary for efficient in-memory
    storage and retrieval of tasks.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an empty task list."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1

    def _validate_task_id(self, task_id: int) -> None:
        """
        Internal helper to validate a task ID.

        Raises:
            TypeError: If task_id is not an integer.
            TaskNotFoundError: If no task with the given ID exists.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task with ID '{task_id}' not found.")

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name of the task (must be a non-empty string).
            task_description: A detailed description of the task.

        Returns:
            The unique ID assigned to the new task.

        Raises:
            InvalidTaskDataError: If task_name is empty or invalid.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise InvalidTaskDataError("Task name cannot be empty.")
        if not isinstance(task_description, str):
            # Allow empty description, but ensure it's a string
            task_description = ""

        current_id = self._next_id
        new_task = Task(
            id=current_id,
            name=task_name.strip(),
            description=task_description.strip()
        )
        self._tasks[current_id] = new_task
        self._next_id += 1
        return current_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its unique ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed, False otherwise.
            (Note: This implementation raises errors on failure instead).
        
        Raises:
            TaskNotFoundError: If the task_id does not exist.
            TypeError: If task_id is not an integer.
        """
        self._validate_task_id(task_id)
        del self._tasks[task_id]
        return True

    def search(self, search_term: str) -> List[Dict[str, Any]]:
        """
        Searches for tasks by name or description. The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of tasks (as dictionaries) that match the search term.
            Returns an empty list if no matches are found.
        
        Raises:
            InvalidTaskDataError: If search_term is empty or invalid.
        """
        if not isinstance(search_term, str) or not search_term.strip():
            raise InvalidTaskDataError("Search term cannot be empty.")

        term_lower = search_term.lower().strip()
        
        results = [
            task.to_dict()
            for task in self._tasks.values()
            if term_lower in task.name.lower() or term_lower in task.description.lower()
        ]
        return results

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished.

        Raises:
            TaskNotFoundError: If the task_id does not exist.
            TypeError: If task_id is not an integer.
        """
        self._validate_task_id(task_id)
        self._tasks[task_id].is_finished = True
        return True

    def get_all(self) -> List[Dict[str, Any]]:
        """
        Retrieves all tasks.

        Returns:
            A list containing all tasks as dictionaries.
        """
        return [task.to_dict() for task in self._tasks.values()]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the manager.

        Returns:
            True indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1  # Reset the ID counter
        return True


# --- Console User Interface (for demonstration) ---

def print_tasks(tasks: List[Dict[str, Any]]) -> None:
    """Helper function to print a list of tasks in a readable format."""
    if not tasks:
        print("No tasks to display.")
        return

    # Find max width for alignment
    max_name_len = max(len(t['name']) for t in tasks) if tasks else 0
    header_name = "Name".ljust(max_name_len)

    print("-" * 80)
    print(f"| {'ID':<4} | {header_name} | {'Status':<10} | Description")
    print("-" * 80)

    for task in sorted(tasks, key=lambda t: t['id']):
        status = "Finished" if task['is_finished'] else "Pending"
        name = task['name'].ljust(max_name_len)
        print(f"| {task['id']:<4} | {name} | {status:<10} | {task['description']}")
    print("-" * 80)


def main() -> None:
    """Main function to run the console-based To-Do application."""
    manager = TaskManager()
    print("Welcome to the Console To-Do List App!")

    # Pre-populate with some data for demonstration
    manager.add("Buy groceries", "Milk, Bread, Cheese, Eggs")
    manager.add("Finish report", "Complete the Q3 sales report for marketing.")
    manager.add("Call mom", "Check in and see how she's doing.")

    while True:
        print("\n--- Menu ---")
        print("1. Add a new task")
        print("2. Remove a task by ID")
        print("3. Mark a task as finished")
        print("4. List all tasks")
        print("5. Search for a task")
        print("6. Clear all tasks")
        print("7. Exit")

        choice = input("Enter your choice: ")

        try:
            if choice == '1':
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"✅ Success: Task '{name}' added with ID {task_id}.")
            
            elif choice == '2':
                task_id_str = input("Enter task ID to remove: ")
                manager.remove(int(task_id_str))
                print(f"✅ Success: Task {task_id_str} has been removed.")
            
            elif choice == '3':
                task_id_str = input("Enter task ID to mark as finished: ")
                manager.finish(int(task_id_str))
                print(f"✅ Success: Task {task_id_str} marked as finished.")

            elif choice == '4':
                print("\n--- All Tasks ---")
                print_tasks(manager.get_all())

            elif choice == '5':
                term = input("Enter search term: ")
                results = manager.search(term)
                print(f"\n--- Search Results for '{term}' ---")
                print_tasks(results)

            elif choice == '6':
                confirm = input("Are you sure you want to delete ALL tasks? (y/n): ")
                if confirm.lower() == 'y':
                    manager.clear_all()
                    print("✅ Success: All tasks have been cleared.")
                else:
                    print("Operation cancelled.")

            elif choice == '7':
                print("Exiting. Goodbye!")
                break
            
            else:
                print("❌ Error: Invalid choice. Please enter a number from 1 to 7.")

        except (TaskNotFoundError, InvalidTaskDataError) as e:
            print(f"❌ Error: {e}")
        except ValueError:
            print("❌ Error: Invalid input. Please enter a valid number for the task ID.")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    main()
```