Of course. As a senior software developer, I will provide a high-quality, maintainable, and well-documented Python implementation for a console-based todo list application.

This solution adheres to the ISO/IEC 25010 standard by focusing on:
*   **Maintainability & Modularity:** The core logic is encapsulated within the `TaskManager` class, completely separate from the user interface. This makes the code easy to understand, modify, and test.
*   **Reliability & Safety:** Robust error handling and input validation are implemented to ensure the application behaves predictably and protects against invalid data.
*   **Performance Efficiency:** The choice of a dictionary for in-memory storage ensures optimal time complexity (O(1) on average) for key operations like adding, removing, and retrieving tasks by ID.
*   **Functional Suitability:** The code correctly implements all the specified functionalities.
*   **Testability:** The `TaskManager` class has no external dependencies (like files or databases), making it straightforward to unit test.
*   **Readability:** The code uses clear variable names, comprehensive docstrings, and type hints, making it easy for other developers to read and use.

Here is the complete implementation:

```python
"""
A high-quality, console-based Todo List application in Python.

This module provides a TaskManager class that encapsulates all the logic for
managing tasks, adhering to best practices for creating maintainable and robust
software as outlined by the ISO/IEC 25010 standard.
"""

import sys
from typing import List, Dict, TypedDict, Any

# Define a precise type for a task dictionary for clarity and static analysis.
# This improves maintainability and readability.
class Task(TypedDict):
    """Represents the structure of a single task."""
    id: int
    name: str
    description: str
    is_finished: bool


class TaskManager:
    """
    Manages a collection of tasks in memory.

    This class provides the core business logic for the todo list application,
    including adding, removing, searching, and updating tasks. It is designed
    to be modular and independent of the user interface.

    Attributes:
        _tasks (Dict[int, Task]): A dictionary to store tasks, with the task ID
                                  as the key for efficient lookups.
        _next_id (int): A counter to generate unique IDs for new tasks.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an empty task list."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name of the task. Cannot be an empty string.
            task_description: A detailed description of the task.

        Returns:
            The unique ID of the newly created task.

        Raises:
            ValueError: If task_name is empty or just whitespace.
            TypeError: If task_name or task_description are not strings.
        """
        if not isinstance(task_name, str) or not isinstance(task_description, str):
            raise TypeError("Task name and description must be strings.")
        if not task_name.strip():
            raise ValueError("Task name cannot be empty.")

        task_id = self._next_id
        new_task: Task = {
            "id": task_id,
            "name": task_name.strip(),
            "description": task_description.strip(),
            "is_finished": False,
        }
        self._tasks[task_id] = new_task
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its unique ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed, False otherwise.

        Raises:
            TypeError: If task_id is not an integer.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id in self._tasks:
            del self._tasks[task_id]
            return True
        return False

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished, False otherwise.

        Raises:
            TypeError: If task_id is not an integer.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id in self._tasks:
            self._tasks[task_id]["is_finished"] = True
            return True
        return False

    def search(self, search_term: str) -> List[Task]:
        """
        Searches for tasks by a search term in their name or description.

        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of tasks (as dictionaries) that match the search term.

        Raises:
            TypeError: If search_term is not a string.
        """
        if not isinstance(search_term, str):
            raise TypeError("Search term must be a string.")
        
        lower_term = search_term.lower()
        if not lower_term.strip():
            return [] # Return empty list for empty search term

        return [
            task
            for task in self._tasks.values()
            if lower_term in task["name"].lower() or lower_term in task["description"].lower()
        ]

    def get_all(self) -> List[Task]:
        """
        Retrieves all tasks.

        Returns:
            A list of all tasks, sorted by their ID.
        """
        # Returning a sorted list provides a consistent and predictable order.
        return sorted(self._tasks.values(), key=lambda task: task["id"])

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the list.

        Returns:
            True, indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1
        return True


def print_task(task: Task) -> None:
    """Helper function to print a single task in a readable format."""
    status = "Finished" if task["is_finished"] else "Pending"
    print(
        f"  ID: {task['id']}\n"
        f"  Name: {task['name']}\n"
        f"  Description: {task['description']}\n"
        f"  Status: {status}\n"
        f"  --------------------"
    )


def main() -> None:
    """
    Main function to run the console-based UI for the Todo List App.

    This function handles user input, calls the appropriate TaskManager methods,
    and displays the results or errors to the user.
    """
    manager = TaskManager()
    print("--- Console Todo List App ---")

    # Pre-populate with some data for demonstration
    manager.add("Buy groceries", "Milk, Bread, Cheese")
    manager.add("Finish report", "Complete the Q3 financial report for the meeting.")
    manager.add("Call plumber", "Fix the leaky faucet in the kitchen.")

    while True:
        print("\nCommands: add, remove, finish, search, list, clear, exit")
        command = input("> ").lower().strip()

        try:
            if command == "add":
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"Success: Task added with ID: {task_id}")

            elif command == "remove":
                task_id_str = input("Enter task ID to remove: ")
                task_id = int(task_id_str)
                if manager.remove(task_id):
                    print(f"Success: Task {task_id} removed.")
                else:
                    print(f"Error: Task with ID {task_id} not found.")

            elif command == "finish":
                task_id_str = input("Enter task ID to finish: ")
                task_id = int(task_id_str)
                if manager.finish(task_id):
                    print(f"Success: Task {task_id} marked as finished.")
                else:
                    print(f"Error: Task with ID {task_id} not found.")

            elif command == "search":
                term = input("Enter search term: ")
                results = manager.search(term)
                print(f"\nFound {len(results)} matching task(s):")
                if not results:
                    print("  No tasks found.")
                else:
                    for task in results:
                        print_task(task)

            elif command == "list":
                all_tasks = manager.get_all()
                print(f"\nDisplaying {len(all_tasks)} task(s):")
                if not all_tasks:
                    print("  Your todo list is empty.")
                else:
                    for task in all_tasks:
                        print_task(task)

            elif command == "clear":
                confirm = input("Are you sure you want to delete all tasks? (y/n): ").lower()
                if confirm == 'y':
                    manager.clear_all()
                    print("Success: All tasks have been cleared.")
                else:
                    print("Operation cancelled.")

            elif command == "exit":
                print("Exiting application. Goodbye!")
                sys.exit(0)

            else:
                print("Error: Unknown command. Please try again.")

        except (ValueError, TypeError) as e:
            # Gracefully handle validation errors from the TaskManager
            print(f"Error: {e}")
        except Exception as e:
            # Catch any other unexpected errors
            print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    main()
```