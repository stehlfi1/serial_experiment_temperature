Of course. As a senior software developer, I will provide a high-quality Python implementation for a console-based todo list application. The solution will be structured within a `TaskManager` class, adhering to the principles of the ISO/IEC 25010 standard for software quality.

### Design Philosophy (Adherence to ISO/IEC 25010)

*   **Functional Suitability:** The code directly implements all required functionalities (`add`, `remove`, etc.) to meet the user's needs.
*   **Performance Efficiency:** The core data structure is a dictionary, providing average O(1) time complexity for critical operations like adding, removing, and finishing tasks by their ID. Search operations are O(n), which is optimal without a more complex indexing system.
*   **Maintainability & Modularity:** The logic is encapsulated within the `TaskManager` class. Methods are single-purpose, well-documented, and independent, making the system easy to understand, modify, and debug.
*   **Reliability & Safety:** Robust validation is implemented using standard Python exceptions (`ValueError`, `TypeError`) to handle invalid inputs. The system is designed to be fault-tolerant, preventing crashes from incorrect usage.
*   **Usability (for the developer):** The class provides a clean, predictable, and well-documented API. Type hints and clear docstrings make it easy for other developers to integrate and use.
*   **Testability:** The class is self-contained and does not rely on external state (like files or databases), making it straightforward to instantiate and test in an automated testing framework like `pytest` or `unittest`.

Here is the complete, high-quality Python code.

```python
"""
A high-quality, maintainable implementation of a console-based Todo List Manager.

This module provides the TaskManager class, which follows the principles of the
ISO/IEC 25010 standard for software quality, emphasizing correctness, performance,
modularity, and safety.
"""

from __future__ import annotations
import typing

# Define a type alias for a task dictionary for better readability and maintenance.
Task = typing.Dict[str, typing.Union[int, str, bool]]


class TaskManager:
    """
    Manages a collection of tasks in memory.

    This class provides a complete interface to add, remove, search, finish,
    and retrieve tasks, ensuring data integrity and efficient operations.

    Attributes:
        _tasks (dict[int, Task]): A private dictionary to store tasks,
                                  mapping a unique task ID to a task object.
        _next_id (int): A private counter to generate unique task IDs.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an empty task list."""
        self._tasks: dict[int, Task] = {}
        self._next_id: int = 1

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the manager.

        Args:
            task_name: The name of the task. Must be a non-empty string.
            task_description: A description for the task.

        Returns:
            The unique ID assigned to the newly created task.

        Raises:
            TypeError: If task_name or task_description are not strings.
            ValueError: If task_name is an empty or whitespace-only string.
        """
        if not isinstance(task_name, str) or not isinstance(task_description, str):
            raise TypeError("Task name and description must be strings.")
        if not task_name.strip():
            raise ValueError("Task name cannot be empty.")

        task_id = self._next_id
        self._tasks[task_id] = {
            "id": task_id,
            "name": task_name.strip(),
            "description": task_description.strip(),
            "is_finished": False,
        }
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its unique ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed, False otherwise.

        Raises:
            TypeError: If task_id is not an integer.
            ValueError: If task_id is negative.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id < 0:
            raise ValueError("Task ID cannot be negative.")

        if task_id in self._tasks:
            del self._tasks[task_id]
            return True
        return False

    def search(self, search_term: str) -> list[Task]:
        """
        Searches for tasks by a search term in their name or description.

        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of task dictionaries that match the search term.

        Raises:
            TypeError: If search_term is not a string.
        """
        if not isinstance(search_term, str):
            raise TypeError("Search term must be a string.")

        lower_search_term = search_term.lower()
        return [
            task
            for task in self._tasks.values()
            if lower_search_term in task["name"].lower()
            or lower_search_term in task["description"].lower()
        ]

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as completed.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished, False otherwise.

        Raises:
            TypeError: If task_id is not an integer.
            ValueError: If task_id is negative.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id < 0:
            raise ValueError("Task ID cannot be negative.")

        if task_id in self._tasks:
            self._tasks[task_id]["is_finished"] = True
            return True
        return False

    def get_all(self) -> list[Task]:
        """
        Retrieves all tasks.

        Returns:
            A list containing all task dictionaries. Returns a copy to prevent
            unintended modification of the internal task list.
        """
        return list(self._tasks.values())

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the manager.

        This action is irreversible and also resets the task ID counter.

        Returns:
            True, indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1
        return True


# --- Example Usage ---
def main() -> None:
    """
    Demonstrates the usage of the TaskManager class.
    This function serves as a simple command-line interface and a
    demonstration of the class's functionality and error handling.
    """
    print("--- Task Manager Demonstration ---")
    manager = TaskManager()

    # 1. Add tasks
    print("\n1. Adding tasks...")
    try:
        id1 = manager.add("Buy groceries", "Milk, Bread, Cheese")
        print(f"  - Added task with ID: {id1}")
        id2 = manager.add("Finish report", "Q3 financial report for management.")
        print(f"  - Added task with ID: {id2}")
        id3 = manager.add("Call plumber", "Fix the leaky faucet in the kitchen.")
        print(f"  - Added task with ID: {id3}")
    except (ValueError, TypeError) as e:
        print(f"  Error adding task: {e}")

    # 2. Get all tasks
    print("\n2. Current tasks:")
    all_tasks = manager.get_all()
    for task in all_tasks:
        print(f"  - {task}")

    # 3. Finish a task
    print(f"\n3. Finishing task with ID {id2}...")
    if manager.finish(id2):
        print(f"  - Task {id2} marked as finished.")
    else:
        print(f"  - Task {id2} not found.")

    print("\n   Current tasks after finishing one:")
    for task in manager.get_all():
        print(f"  - {task}")

    # 4. Search for tasks
    search_key = "report"
    print(f"\n4. Searching for tasks containing '{search_key}'...")
    search_results = manager.search(search_key)
    if search_results:
        for task in search_results:
            print(f"  - Found: {task}")
    else:
        print("  - No tasks found.")

    # 5. Remove a task
    task_to_remove = id1
    print(f"\n5. Removing task with ID {task_to_remove}...")
    if manager.remove(task_to_remove):
        print(f"  - Task {task_to_remove} removed successfully.")
    else:
        print(f"  - Task {task_to_remove} not found.")

    print("\n   Current tasks after removal:")
    for task in manager.get_all():
        print(f"  - {task}")

    # 6. Demonstrate error handling
    print("\n6. Demonstrating error handling...")
    print("  - Attempting to add a task with an empty name...")
    try:
        manager.add("   ", "This should fail.")
    except ValueError as e:
        print(f"    -> Caught expected error: {e}")

    print("  - Attempting to remove a non-existent task (ID 99)...")
    if not manager.remove(99):
        print("    -> Correctly handled non-existent task.")

    # 7. Clear all tasks
    print("\n7. Clearing all tasks...")
    if manager.clear_all():
        print("  - All tasks have been cleared.")

    print("\n   Final task list:")
    print(f"  - {manager.get_all()}")
    print("\n--- Demonstration Complete ---")


if __name__ == "__main__":
    main()
```