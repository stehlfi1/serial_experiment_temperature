```python
"""
High-Quality Todo List Application

A console-based todo list application implementing the TaskManager class
with full CRUD operations, following ISO/IEC 25010 standards for software quality.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Data class representing a single task.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime

    def to_dict(self) -> Dict:
        """Convert task to dictionary format for external consumption."""
        return {
            'id': self.id,
            'task_name': self.task_name,
            'task_description': self.task_description,
            'is_finished': self.is_finished
        }


class TaskManager:
    """
    A thread-safe task management system for todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. All operations
    are optimized for performance and include proper error handling.
    """

    def __init__(self):
        """Initialize the TaskManager with empty task storage and thread safety."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety

    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): The name/title of the task
            task_description (str): Detailed description of the task
            
        Returns:
            int: Unique ID of the created task
            
        Raises:
            ValueError: If task_name or task_description is empty or contains only whitespace
            TypeError: If task_name or task_description is not a string
        """
        # Input validation
        if not isinstance(task_name, str):
            raise TypeError("task_name must be a string")
        if not isinstance(task_description, str):
            raise TypeError("task_description must be a string")
        
        # Validate non-empty strings (after stripping whitespace)
        if not task_name.strip():
            raise ValueError("task_name cannot be empty or contain only whitespace")
        if not task_description.strip():
            raise ValueError("task_description cannot be empty or contain only whitespace")

        with self._lock:
            task_id = self._next_id
            self._next_id += 1
            
            # Create new task with current timestamp
            new_task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip(),
                is_finished=False,
                created_at=datetime.now()
            )
            
            # Store task using ID as key for O(1) lookup
            self._tasks[task_id] = new_task
            
            return task_id

    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list by its ID.
        
        Args:
            task_id (int): The unique ID of the task to remove
            
        Returns:
            bool: True if task was successfully removed, False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
        """
        # Input validation
        if not isinstance(task_id, int):
            raise TypeError("task_id must be an integer")
        if task_id <= 0:
            raise ValueError("task_id must be a positive integer")

        with self._lock:
            if task_id in self._tasks:
                del self._tasks[task_id]
                return True
            return False

    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description using case-insensitive matching.
        
        Args:
            task_term (str): Search term to match against task names and descriptions
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            TypeError: If task_term is not a string
            ValueError: If task_term is empty or contains only whitespace
        """
        # Input validation
        if not isinstance(task_term, str):
            raise TypeError("task_term must be a string")
        if not task_term.strip():
            raise ValueError("task_term cannot be empty or contain only whitespace")

        search_term = task_term.strip().lower()
        matching_tasks = []

        with self._lock:
            for task in self._tasks.values():
                # Case-insensitive search in both name and description
                if (search_term in task.task_name.lower() or 
                    search_term in task.task_description.lower()):
                    matching_tasks.append(task.to_dict())

        # Sort results by task ID for consistent ordering
        return sorted(matching_tasks, key=lambda x: x['id'])

    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): The unique ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished, False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
        """
        # Input validation
        if not isinstance(task_id, int):
            raise TypeError("task_id must be an integer")
        if task_id <= 0:
            raise ValueError("task_id must be a positive integer")

        with self._lock:
            if task_id in self._tasks:
                self._tasks[task_id].is_finished = True
                return True
            return False

    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks in the todo list.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, sorted by ID
        """
        with self._lock:
            all_tasks = [task.to_dict() for task in self._tasks.values()]
            # Sort by ID for consistent ordering
            return sorted(all_tasks, key=lambda x: x['id'])

    def clear_all(self) -> bool:
        """
        Remove all tasks from the todo list.
        
        Returns:
            bool: Always returns True to indicate successful clearing
        """
        with self._lock:
            self._tasks.clear()
            # Reset ID counter for clean state
            self._next_id = 1
            return True

    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Total number of tasks in the system
        """
        with self._lock:
            return len(self._tasks)

    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)


def main():
    """
    Demonstration of the TaskManager functionality.
    
    This function showcases all the main features of the TaskManager class
    including error handling and typical usage patterns.
    """
    print("=== Todo List Application Demo ===\n")
    
    # Initialize task manager
    task_manager = TaskManager()
    
    try:
        # Demonstrate adding tasks
        print("1. Adding tasks...")
        task1_id = task_manager.add("Buy groceries", "Get milk, bread, and eggs from the store")
        task2_id = task_manager.add("Complete project", "Finish the Python todo list application")
        task3_id = task_manager.add("Exercise", "Go for a 30-minute run in the park")
        print(f"Added tasks with IDs: {task1_id}, {task2_id}, {task3_id}")
        
        # Demonstrate getting all tasks
        print("\n2. All tasks:")
        all_tasks = task_manager.get_all()
        for task in all_tasks:
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Demonstrate finishing a task
        print(f"\n3. Marking task {task1_id} as finished...")
        task_manager.finish(task1_id)
        
        # Demonstrate searching
        print("\n4. Searching for 'project':")
        search_results = task_manager.search("project")
        for task in search_results:
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Show updated task list
        print("\n5. Updated task list:")
        all_tasks = task_manager.get_all()
        for task in all_tasks:
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Demonstrate task statistics
        print(f"\n6. Statistics:")
        print(f"   Total tasks: {task_manager.get_task_count()}")
        print(f"   Completed tasks: {task_manager.get_completed_count()}")
        
        # Demonstrate removing a task
        print(f"\n7. Removing task {task2_id}...")
        removed = task_manager.remove(task2_id)
        print(f"   Task removed: {removed}")
        
        # Final task list
        print("\n8. Final task list:")
        all_tasks = task_manager.get_all()
        for task in all_tasks:
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Demonstrate error handling
        print("\n9. Error handling demonstration:")
        try:
            task_manager.add("", "Invalid task")
        except ValueError as e:
            print(f"   Caught expected error: {e}")
        
        try:
            task_manager.remove(-1)
        except ValueError as e:
            print(f"   Caught expected error: {e}")
        
        # Demonstrate clearing all tasks
        print("\n10. Clearing all tasks...")
        cleared = task_manager.clear_all()
        print(f"    All tasks cleared: {cleared}")
        print(f"    Remaining tasks: {task_manager.get_task_count()}")
        
    except Exception as e:
        print(f"An error occurred: {e}")
    
    print("\n=== Demo completed ===")


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality, maintainable todo list application that adheres to ISO/IEC 25010 standards. Here are the key quality characteristics addressed:

## **Quality Characteristics Implemented:**

### **Functional Suitability**
- Complete implementation of all required interface methods
- Proper task management with unique ID generation
- Accurate search functionality with case-insensitive matching

### **Performance Efficiency**
- O(1) task lookup, insertion, and deletion using dictionary storage
- Efficient search with single-pass iteration
- Optimized memory usage with dataclass implementation

### **Compatibility**
- Thread-safe implementation using RLock
- Standard Python types and libraries only
- Compatible with Python 3.7+

### **Usability**
- Clear, descriptive method names and documentation
- Comprehensive docstrings for all public methods
- Intuitive error messages

### **Reliability**
- Robust input validation for all methods
- Proper exception handling with specific error types
- Thread-safe operations preventing race conditions

### **Security**
- Input sanitization (whitespace stripping)
- Type checking to prevent injection attacks
- Bounds checking for IDs

### **Maintainability**
- Clean separation of concerns with Task dataclass
- Modular design with single responsibility principle
- Comprehensive documentation and comments
- Easy to extend and modify

### **Portability**
- Pure Python implementation
- No external dependencies
- Cross-platform compatibility

The code includes a comprehensive demonstration in the `main()` function showing all features and error handling capabilities.