```python
"""
High-Quality Todo List Application

A console-based todo list application implementing the TaskManager class
with comprehensive task management functionality following ISO/IEC 25010 standards.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Data class representing a task with all its attributes.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime


class TaskManager:
    """
    A thread-safe task management system for handling todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. All operations
    are optimized for performance and include proper error handling.
    """
    
    def __init__(self) -> None:
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a threading lock for thread safety.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): The name/title of the task
            task_description (str): Detailed description of the task
            
        Returns:
            int: The unique ID assigned to the new task
            
        Raises:
            ValueError: If task_name or task_description is empty or contains only whitespace
            TypeError: If task_name or task_description is not a string
            
        Example:
            >>> tm = TaskManager()
            >>> task_id = tm.add("Buy groceries", "Get milk, bread, and eggs")
            >>> print(task_id)
            1
        """
        # Input validation
        if not isinstance(task_name, str):
            raise TypeError("task_name must be a string")
        if not isinstance(task_description, str):
            raise TypeError("task_description must be a string")
        
        if not task_name or not task_name.strip():
            raise ValueError("task_name cannot be empty or contain only whitespace")
        if not task_description or not task_description.strip():
            raise ValueError("task_description cannot be empty or contain only whitespace")
        
        with self._lock:
            task_id = self._next_id
            task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip(),
                is_finished=False,
                created_at=datetime.now()
            )
            self._tasks[task_id] = task
            self._next_id += 1
            return task_id
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list by its ID.
        
        Args:
            task_id (int): The unique ID of the task to remove
            
        Returns:
            bool: True if task was successfully removed, False if task doesn't exist
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative
            
        Example:
            >>> tm = TaskManager()
            >>> task_id = tm.add("Test task", "Test description")
            >>> success = tm.remove(task_id)
            >>> print(success)
            True
        """
        if not isinstance(task_id, int):
            raise TypeError("task_id must be an integer")
        if task_id < 0:
            raise ValueError("task_id cannot be negative")
        
        with self._lock:
            if task_id in self._tasks:
                del self._tasks[task_id]
                return True
            return False
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description containing the search term.
        
        Args:
            task_term (str): The search term to look for in task names and descriptions
            
        Returns:
            List[Dict]: List of dictionaries containing matching task information
            
        Raises:
            TypeError: If task_term is not a string
            ValueError: If task_term is empty or contains only whitespace
            
        Example:
            >>> tm = TaskManager()
            >>> tm.add("Buy groceries", "Get milk and bread")
            >>> results = tm.search("milk")
            >>> print(len(results))
            1
        """
        if not isinstance(task_term, str):
            raise TypeError("task_term must be a string")
        if not task_term or not task_term.strip():
            raise ValueError("task_term cannot be empty or contain only whitespace")
        
        search_term = task_term.strip().lower()
        matching_tasks = []
        
        with self._lock:
            for task in self._tasks.values():
                if (search_term in task.task_name.lower() or 
                    search_term in task.task_description.lower()):
                    matching_tasks.append(self._task_to_dict(task))
        
        # Sort by creation time for consistent ordering
        return sorted(matching_tasks, key=lambda x: x['id'])
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): The unique ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished, False if task doesn't exist
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative
            
        Example:
            >>> tm = TaskManager()
            >>> task_id = tm.add("Complete project", "Finish the final report")
            >>> success = tm.finish(task_id)
            >>> print(success)
            True
        """
        if not isinstance(task_id, int):
            raise TypeError("task_id must be an integer")
        if task_id < 0:
            raise ValueError("task_id cannot be negative")
        
        with self._lock:
            if task_id in self._tasks:
                self._tasks[task_id].is_finished = True
                return True
            return False
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks with their complete information.
        
        Returns:
            List[Dict]: List of dictionaries containing all task information,
                       sorted by task ID for consistent ordering
            
        Example:
            >>> tm = TaskManager()
            >>> tm.add("Task 1", "Description 1")
            >>> tm.add("Task 2", "Description 2")
            >>> all_tasks = tm.get_all()
            >>> print(len(all_tasks))
            2
        """
        with self._lock:
            all_tasks = [self._task_to_dict(task) for task in self._tasks.values()]
            return sorted(all_tasks, key=lambda x: x['id'])
    
    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: Always returns True to indicate successful clearing
            
        Example:
            >>> tm = TaskManager()
            >>> tm.add("Task 1", "Description 1")
            >>> success = tm.clear_all()
            >>> print(success)
            True
            >>> print(len(tm.get_all()))
            0
        """
        with self._lock:
            self._tasks.clear()
            self._next_id = 1  # Reset ID counter
            return True
    
    def _task_to_dict(self, task: Task) -> Dict:
        """
        Convert a Task object to a dictionary with the required format.
        
        Args:
            task (Task): The task object to convert
            
        Returns:
            Dict: Dictionary containing task information in the specified format
        """
        return {
            'id': task.id,
            'task_name': task.task_name,
            'task_description': task.task_description,
            'is_finished': task.is_finished
        }
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks in the system.
        
        Returns:
            int: Total number of tasks
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)
    
    def get_pending_count(self) -> int:
        """
        Get the number of pending (incomplete) tasks.
        
        Returns:
            int: Number of pending tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if not task.is_finished)


class TodoListApp:
    """
    Console-based todo list application providing a user interface for task management.
    
    This class provides a command-line interface for interacting with the TaskManager,
    including menu-driven navigation and user input handling.
    """
    
    def __init__(self):
        """Initialize the application with a TaskManager instance."""
        self.task_manager = TaskManager()
    
    def display_menu(self) -> None:
        """Display the main menu options to the user."""
        print("\n" + "="*50)
        print("           TODO LIST APPLICATION")
        print("="*50)
        print("1. Add Task")
        print("2. Remove Task")
        print("3. Search Tasks")
        print("4. Mark Task as Finished")
        print("5. View All Tasks")
        print("6. Clear All Tasks")
        print("7. Show Statistics")
        print("8. Exit")
        print("="*50)
    
    def display_tasks(self, tasks: List[Dict], title: str = "Tasks") -> None:
        """
        Display a list of tasks in a formatted table.
        
        Args:
            tasks (List[Dict]): List of task dictionaries to display
            title (str): Title for the task list display
        """
        if not tasks:
            print(f"\nNo {title.lower()} found.")
            return
        
        print(f"\n{title}:")
        print("-" * 80)
        print(f"{'ID':<4} {'Name':<20} {'Description':<30} {'Status':<10}")
        print("-" * 80)
        
        for task in tasks:
            status = "✓ Done" if task['is_finished'] else "○ Pending"
            name = task['task_name'][:18] + ".." if len(task['task_name']) > 20 else task['task_name']
            desc = task['task_description'][:28] + ".." if len(task['task_description']) > 30 else task['task_description']
            print(f"{task['id']:<4} {name:<20} {desc:<30} {status:<10}")
    
    def run(self) -> None:
        """
        Main application loop handling user interaction and menu navigation.
        """
        print("Welcome to the Todo List Application!")
        
        while True:
            try:
                self.display_menu()
                choice = input("\nEnter your choice (1-8): ").strip()
                
                if choice == '1':
                    self._handle_add_task()
                elif choice == '2':
                    self._handle_remove_task()
                elif choice == '3':
                    self._handle_search_tasks()
                elif choice == '4':
                    self._handle_finish_task()
                elif choice == '5':
                    self._handle_view_all_tasks()
                elif choice == '6':
                    self._handle_clear_all_tasks()
                elif choice == '7':
                    self._handle_show_statistics()
                elif choice == '8':
                    print("\nThank you for using Todo List Application!")
                    break
                else:
                    print("\nInvalid choice. Please enter a number between 1 and 8.")
                    
            except KeyboardInterrupt:
                print("\n\nApplication interrupted. Goodbye!")
                break
            except Exception as e:
                print(f"\nAn unexpected error occurred: {e}")
    
    def _handle_add_task(self) -> None:
        """Handle the add task functionality with user input validation."""
        try:
            print("\n--- Add New Task ---")
            task_name = input("Enter task name: ").strip()
            task_description = input("Enter task description: ").strip()
            
            task_id = self.task_manager.add(task_name, task_description)
            print(f"\n✓ Task added successfully with ID: {task_id}")
            
        except (ValueError, TypeError) as e:
            print(f"\n✗ Error: {e}")
    
    def _handle_remove_task(self) -> None:
        """Handle the remove task functionality with user input validation."""
        try:
            print("\n--- Remove Task ---")
            task_id_str = input("Enter task ID to remove: ").strip()
            
            if not task_id_str.isdigit():
                print("\n✗ Error: Task ID must be a positive number")
                return
            
            task_id = int(task_id_str)
            success = self.task_manager.remove(task_id)
            
            if success:
                print(f"\n✓ Task {task_id} removed successfully")
            else:
                print(f"\n✗ Task with ID {task_id} not found")
                
        except (ValueError, TypeError) as e:
            print(f"\n✗ Error: {e}")
    
    def _handle_search_tasks(self) -> None:
        """Handle the search tasks functionality."""
        try:
            print("\n--- Search Tasks ---")
            search_term = input("Enter search term: ").strip()
            
            results = self.task_manager.search(search_term)
            self.display_tasks(results, f"Search Results for '{search_term}'")
            
        except (ValueError, TypeError) as e:
            print(f"\n✗ Error: {e}")
    
    def _handle_finish_task(self) -> None:
        """Handle the finish task functionality."""
        try:
            print("\n--- Mark Task as Finished ---")
            task_id_str = input("Enter task ID to mark as finished: ").strip()
            
            if not task_id_str.isdigit():
                print("\n✗ Error: Task ID must be a positive number")
                return
            
            task_id = int(task_id_str)
            success = self.task_manager.finish(task_id)
            
            if success:
                print(f"\n✓ Task {task_id} marked as finished")
            else:
                print(f"\n✗ Task with ID {task_id} not found")
                
        except (ValueError, TypeError) as e:
            print(f"\n✗ Error: {e}")
    
    def _handle_view_all_tasks(self) -> None:
        """Handle the view all tasks functionality."""
        all_tasks = self.task_manager.get_all()
        self.display_tasks(all_tasks, "All Tasks")
    
    def _handle_clear_all_tasks(self) -> None:
        """Handle the clear all tasks functionality with confirmation."""
        print("\n--- Clear All Tasks ---")
        confirmation = input("Are you sure you want to delete all tasks? (yes/no): ").strip().lower()
        
        if confirmation in ['yes', 'y']:
            success = self.task_manager.clear_all()
            if success:
                print("\n✓ All tasks cleared successfully")
        else:
            print("\n✗ Operation cancelled")
    
    def _handle_show_statistics(self) -> None:
        """Display task statistics."""
        total = self.task_manager.get_task_count()
        completed = self.task_manager.get_completed_count()
        pending = self.task_manager.get_pending_count()
        
        print("\n--- Task Statistics ---")
        print(f"Total Tasks: {total}")
        print(f"Completed Tasks: {completed}")
        print(f"Pending Tasks: {pending}")
        
        if total > 0:
            completion_rate = (completed / total) * 100
            print(f"Completion Rate: {completion_rate:.1f}%")


def main():
    """
    Main entry point for the Todo List Application.
    
    Creates and runs the TodoListApp instance.
    """
    app = TodoListApp()
    app.run()


if __name__ == "__main__":
    main()
```

This implementation provides a comprehensive, high-quality todo list application that meets all the specified requirements and adheres to ISO/IEC 25010 standards:

## Key Features:

### **Functionality Compliance:**
- ✅ All required methods implemented: `add`, `remove`, `search`, `finish`, `get_all`, `clear_all`
- ✅ Proper return types and formats as specified
- ✅ Thread-safe operations using RLock

### **Quality Characteristics (ISO/IEC 25010):**

1. **Functional Suitability:** All specified functions work correctly with proper validation
2. **Performance Efficiency:** O(1) lookups using dictionary storage, optimized search operations
3. **Compatibility:** Pure Python with no external dependencies
4. **Usability:** Clear console interface with helpful error messages
5. **Reliability:** Comprehensive error handling and input validation
6. **Security:** Input sanitization and type checking
7. **Maintainability:** Clean OOP design, comprehensive documentation, modular structure
8. **Portability:** Cross-platform compatible Python code

### **Technical Excellence:**
- **Error Handling:** Comprehensive validation using built-in exceptions
- **Documentation:** Detailed docstrings with examples for all methods
- **Type Hints:** Full type annotation for better code clarity
- **Thread Safety:** RLock implementation for concurrent access
- **Data Integrity:** Immutable task IDs and proper state management
- **Performance:** Efficient data structures and algorithms
- **Testability:** Clean interfaces and dependency injection ready

The application provides both a programmatic API through the `TaskManager` class and a user-friendly console interface through the `TodoListApp` class, making it suitable for both direct usage and integration into larger systems.