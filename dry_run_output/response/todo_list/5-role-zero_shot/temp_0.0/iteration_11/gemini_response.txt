Of course. As a senior software developer, I will provide a solution that not only meets the functional requirements but also exemplifies the principles of high-quality software design as outlined by ISO/IEC 25010.

The code is structured for **maintainability**, **testability**, and **reliability**.

1.  **Modularity**: The business logic (`TaskManager`) is completely decoupled from the user interface (`main` function). This allows the `TaskManager` to be tested independently or even reused in a different context (e.g., a web API).
2.  **Performance Efficiency**: A dictionary (`self._tasks`) is used as the primary data store. This provides O(1) average-case time complexity for core operations like adding, removing, finishing, and retrieving a task by its ID.
3.  **Reliability & Safety**:
    *   Custom exceptions (`TaskNotFoundError`, `InvalidTaskDataError`) are defined to provide clear, semantic error information.
    *   Input validation is strictly enforced at the boundary of the `TaskManager` class, protecting the core logic from invalid data.
    *   The console UI part gracefully handles these exceptions and provides user-friendly feedback.
4.  **Readability & Documentation**: The code is fully type-hinted, follows PEP 8 conventions, and includes comprehensive docstrings for the module, class, and all public methods, explaining their purpose, parameters, return values, and potential exceptions.

Here is the complete, high-quality Python code for the console-based todo list application.

```python
"""
A console-based Todo List application.

This module provides a TaskManager class to handle todo list operations
and a simple command-line interface (CLI) for user interaction.

It adheres to principles of clean architecture by separating business logic
(TaskManager) from the user interface (main function).

ISO/IEC 25010 Compliance Notes:
- Functional Suitability: Implements all specified features (add, remove, etc.).
- Performance Efficiency: Uses a dictionary for O(1) lookups by ID.
- Maintainability: High modularity, clear documentation, and readable code.
- Reliability: Robust error handling with custom, specific exceptions.
- Security: Input validation protects against invalid data entries.
- Testability: Core logic is decoupled from the UI, allowing for easy unit testing.
"""

import sys
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional

# --- Custom Exceptions for Semantic Error Handling ---

class TaskNotFoundError(KeyError):
    """Raised when a task with the specified ID is not found."""
    def __init__(self, task_id: int):
        super().__init__(f"Error: Task with ID '{task_id}' not found.")
        self.task_id = task_id

class InvalidTaskDataError(ValueError):
    """Raised when task data (e.g., name) is invalid."""
    pass

# --- Data Model ---

@dataclass
class Task:
    """
    Represents a single task in the todo list.

    Attributes:
        id: A unique integer identifier for the task.
        name: The name or title of the task.
        description: A more detailed description of the task.
        is_finished: A boolean indicating if the task is completed.
    """
    id: int
    name: str
    description: str
    is_finished: bool = False

# --- Business Logic Layer ---

class TaskManager:
    """
    Manages all operations related to tasks.

    This class encapsulates the data storage and business logic for the
    todo list, ensuring data integrity and providing a clean API.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an in-memory data store."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1

    def _validate_task_id(self, task_id: int) -> None:
        """
        Internal helper to validate a task ID.

        Raises:
            ValueError: If the task_id is not a positive integer.
            TaskNotFoundError: If the task_id does not exist.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise ValueError("Error: Task ID must be a positive integer.")
        if task_id not in self._tasks:
            raise TaskNotFoundError(task_id)

    def _task_to_dict(self, task: Task) -> Dict:
        """Converts a Task object to its dictionary representation."""
        return asdict(task)

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the list.

        Args:
            task_name: The name of the task. Must be a non-empty string.
            task_description: The description of the task.

        Returns:
            The unique ID of the newly created task.

        Raises:
            InvalidTaskDataError: If the task_name is empty or just whitespace.
        """
        if not task_name or not task_name.strip():
            raise InvalidTaskDataError("Error: Task name cannot be empty.")

        task_id = self._next_id
        new_task = Task(
            id=task_id,
            name=task_name.strip(),
            description=task_description.strip()
        )
        self._tasks[task_id] = new_task
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed.

        Raises:
            ValueError: If task_id is not a positive integer.
            TaskNotFoundError: If no task with the given ID exists.
        """
        self._validate_task_id(task_id)
        del self._tasks[task_id]
        return True

    def search(self, search_term: str) -> List[Dict]:
        """
        Searches for tasks by a search term in their name or description.

        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of dictionaries, where each dictionary represents a
            matching task. Returns an empty list if no matches are found.
        """
        if not search_term or not search_term.strip():
            return []

        lower_term = search_term.lower()
        
        # Using a list comprehension for a concise and readable search
        results = [
            self._task_to_dict(task)
            for task in self._tasks.values()
            if lower_term in task.name.lower() or lower_term in task.description.lower()
        ]
        return results

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished.

        Raises:
            ValueError: If task_id is not a positive integer.
            TaskNotFoundError: If no task with the given ID exists.
        """
        self._validate_task_id(task_id)
        self._tasks[task_id].is_finished = True
        return True

    def get_all(self) -> List[Dict]:
        """
        Retrieves all tasks.

        Returns:
            A list of dictionaries representing all tasks, sorted by ID.
        """
        sorted_tasks = sorted(self._tasks.values(), key=lambda task: task.id)
        return [self._task_to_dict(task) for task in sorted_tasks]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the list.

        Returns:
            True upon successful deletion of all tasks.
        """
        self._tasks.clear()
        self._next_id = 1
        return True

# --- Presentation Layer (Console UI) ---

def print_tasks(tasks: List[Dict]) -> None:
    """Formats and prints a list of tasks to the console."""
    if not tasks:
        print("No tasks found.")
        return

    for task in tasks:
        status = "✓ Finished" if task['is_finished'] else "✗ Pending"
        print(
            f"  ID: {task['id']} | Status: {status}\n"
            f"  Name: {task['task_name']}\n"
            f"  Description: {task['task_description']}\n"
            f"  ----------------------------------------"
        )

def get_user_input(prompt: str, required_type: type = str) -> any:
    """
    Safely gets and converts user input to a required type.
    
    Args:
        prompt: The message to display to the user.
        required_type: The type to convert the input to (e.g., int).

    Returns:
        The user's input, converted to the required type.
    """
    while True:
        try:
            user_input = input(prompt)
            return required_type(user_input)
        except (ValueError, TypeError):
            print(f"Invalid input. Please enter a valid {required_type.__name__}.")
        except EOFError:
            print("\nExiting application.")
            sys.exit(0)


def main() -> None:
    """Main function to run the console-based todo list application."""
    manager = TaskManager()
    print("--- Console Todo List Application ---")

    while True:
        print("\nMenu:")
        print("1. Add Task")
        print("2. Remove Task")
        print("3. Mark Task as Finished")
        print("4. List All Tasks")
        print("5. Search Tasks")
        print("6. Clear All Tasks")
        print("7. Exit")

        choice = get_user_input("Enter your choice: ")

        try:
            if choice == '1':
                name = get_user_input("Enter task name: ")
                desc = get_user_input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"Success: Task '{name}' added with ID {task_id}.")
            
            elif choice == '2':
                task_id = get_user_input("Enter task ID to remove: ", int)
                manager.remove(task_id)
                print(f"Success: Task with ID {task_id} removed.")

            elif choice == '3':
                task_id = get_user_input("Enter task ID to finish: ", int)
                manager.finish(task_id)
                print(f"Success: Task with ID {task_id} marked as finished.")

            elif choice == '4':
                print("\n--- All Tasks ---")
                all_tasks = manager.get_all()
                print_tasks(all_tasks)

            elif choice == '5':
                term = get_user_input("Enter search term: ")
                print(f"\n--- Search Results for '{term}' ---")
                results = manager.search(term)
                print_tasks(results)

            elif choice == '6':
                confirm = get_user_input("Are you sure you want to delete all tasks? (y/n): ").lower()
                if confirm == 'y':
                    manager.clear_all()
                    print("Success: All tasks have been cleared.")
                else:
                    print("Operation cancelled.")

            elif choice == '7':
                print("Exiting application. Goodbye!")
                break
            
            else:
                print("Invalid choice. Please select a valid option from the menu.")

        except (TaskNotFoundError, InvalidTaskDataError, ValueError) as e:
            # Catching specific, known errors from the manager or input conversion
            print(f"\nOperation failed: {e}")
        except Exception as e:
            # A general catch-all for unexpected errors
            print(f"\nAn unexpected error occurred: {e}")


if __name__ == "__main__":
    main()
```