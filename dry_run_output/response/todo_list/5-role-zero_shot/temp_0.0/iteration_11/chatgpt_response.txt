```python
"""
Console-Based Todo List App
===========================

This module implements a maintainable and robust Todo List Application,
adhering to ISO/IEC 25010 quality standards. The central class, TaskManager,
provides an efficient in-memory management for tasks, supporting standard todo
functionality with a clean OOP interface.

Author: [Your Name]
Date: 2024-06-09
"""

from typing import List, Dict
import threading

class TaskNotFoundError(Exception):
    """Custom exception for handling missing tasks."""
    pass

class TaskValidationError(ValueError):
    """Custom exception for handling input validation errors."""
    pass

class TaskManager:
    """
    Manages tasks in an in-memory todo list.

    Each task contains:
    - id: Unique int
    - task_name: str
    - task_description: str
    - is_finished: bool
    """

    def __init__(self):
        """Initialize the Task Manager with an empty task list and thread safety."""
        self._tasks: Dict[int, Dict] = {}
        self._next_id: int = 1
        self._lock = threading.Lock()  # Provides thread safety

    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task and return its unique ID.

        Args:
            task_name (str): Name of the task (non-empty).
            task_description (str): Description of the task (non-empty).

        Returns:
            int: Unique task ID.

        Raises:
            TaskValidationError: If any input is invalid.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise TaskValidationError("Task name must be a non-empty string.")
        if not isinstance(task_description, str) or not task_description.strip():
            raise TaskValidationError("Task description must be a non-empty string.")

        with self._lock:
            task_id = self._next_id
            self._tasks[task_id] = {
                "id": task_id,
                "task_name": task_name.strip(),
                "task_description": task_description.strip(),
                "is_finished": False
            }
            self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Remove a task by its ID.

        Args:
            task_id (int): Unique task ID.

        Returns:
            bool: True if task removed, False otherwise.

        Raises:
            TaskValidationError: If task_id is invalid.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise TaskValidationError("Task ID must be a positive integer.")
        with self._lock:
            if task_id in self._tasks:
                del self._tasks[task_id]
                return True
            else:
                return False

    def search(self, task_term: str) -> List[Dict]:
        """
        Search tasks by name or description (case-insensitive substring match).

        Args:
            task_term (str): Substring to search for.

        Returns:
            List[Dict]: List of matching task dictionaries.
        """
        if not isinstance(task_term, str) or not task_term.strip():
            return []  # Empty search returns empty result
        term = task_term.strip().lower()
        with self._lock:
            results = [
                task.copy()
                for task in self._tasks.values()
                if term in task["task_name"].lower() or term in task["task_description"].lower()
            ]
        return results

    def finish(self, task_id: int) -> bool:
        """
        Mark a task as finished.

        Args:
            task_id (int): Unique task ID.

        Returns:
            bool: True if successfully marked as finished, False otherwise.

        Raises:
            TaskValidationError: If task_id is invalid.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise TaskValidationError("Task ID must be a positive integer.")
        with self._lock:
            task = self._tasks.get(task_id)
            if not task:
                return False
            if task["is_finished"]:
                return True  # Already finished
            task["is_finished"] = True
            return True

    def get_all(self) -> List[Dict]:
        """
        Get all tasks with their details.

        Returns:
            List[Dict]: List of task dictionaries (id, task_name, task_description, is_finished).
        """
        with self._lock:
            # Return a shallow copy to protect internal state
            return [task.copy() for task in self._tasks.values()]

    def clear_all(self) -> bool:
        """
        Delete all tasks.

        Returns:
            bool: True if successful.
        """
        with self._lock:
            self._tasks.clear()
        return True

# ============================
# Minimal Test & Demonstration
# ============================

if __name__ == "__main__":
    manager = TaskManager()
    try:
        # Add tasks
        task_id1 = manager.add("Buy milk", "Purchase 2 liters of milk")
        task_id2 = manager.add("Read book", "Read 'Clean Code'")
        print(f"Added tasks: {task_id1}, {task_id2}")
        # List all
        print("All tasks:", manager.get_all())
        # Finish a task
        manager.finish(task_id1)
        # Search
        print("Search for 'milk':", manager.search("milk"))
        print("Search for 'code':", manager.search("code"))
        # Remove
        print("Remove task:", manager.remove(task_id2))
        # Invalid remove
        print("Remove invalid task:", manager.remove(999))
        # Clear all
        manager.clear_all()
        print("All tasks after clearing:", manager.get_all())
    except TaskValidationError as e:
        print("Input validation error:", e)
```
This implementation is:

- **Modular:** Encapsulated in a class with clear, testable methods.  
- **Efficient:** Uses an in-memory dict for O(1) operations by ID.
- **Safe:** Carefully validates inputs and handles edge cases.
- **Documented:** Docstrings and comments for clarity.
- **Extensible:** Easy to expand, refactor, or test.
- **ISO/IEC 25010-compliant:** Focused on correctness, usability, maintainability, and robustness.

Replace `[Your Name]` with your name if desired.