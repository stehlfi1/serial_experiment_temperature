Of course. As a senior software developer, I will provide a high-quality Python implementation for a console-based todo list application. The solution will be structured using Object-Oriented Programming (OOP) and will adhere to the principles outlined in the ISO/IEC 25010 standard for software quality.

### Design Rationale (ISO/IEC 25010 Alignment)

*   **Functional Suitability:** The `TaskManager` class provides a complete and correct implementation of all required functionalities (`add`, `remove`, `search`, etc.).
*   **Performance Efficiency:** For optimal time behavior, tasks are stored in a dictionary (`self._tasks`) using the `task_id` as the key. This allows for near O(1) average-case time complexity for additions, removals, and lookups by ID. Searching remains O(n) as it requires iterating through all tasks.
*   **Maintainability & Modularity:** The core business logic is fully encapsulated within the `TaskManager` class. This separation of concerns makes the code easy to understand, modify, and test. A separate `main` function handles user interaction, decoupling the application logic from the presentation layer.
*   **Reliability & Safety:** The code uses custom exceptions (`TaskNotFoundError`, `InvalidTaskDataError`) for clear, specific error handling. All public methods perform rigorous validation on their inputs (e.g., checking for empty strings, non-positive IDs) to prevent data corruption and ensure fault tolerance.
*   **Testability:** The `TaskManager` class has no external dependencies (like file I/O or databases), making it trivial to instantiate and unit test its methods in isolation.
*   **Readability and Documentation:** The code is thoroughly documented with type hints, docstrings for the class and all methods, and clear variable names, ensuring it is easy for other developers to read and understand.

---

Here is the implementation:

```python
# main.py

import sys
from typing import TypedDict, Dict, List

# --- Data Structures and Custom Exceptions ---

class Task(TypedDict):
    """
    A TypedDict to represent the structure of a single task.
    This improves readability and allows for static analysis.
    """
    id: int
    name: str
    description: str
    is_finished: bool

class TaskNotFoundError(Exception):
    """Custom exception raised when a task with a given ID is not found."""
    pass

class InvalidTaskDataError(ValueError):
    """Custom exception raised for invalid task data, like empty names."""
    pass


# --- Core Application Logic ---

class TaskManager:
    """
    Manages a collection of tasks with functionalities to add, remove,
    search, and update tasks.

    Attributes:
        _tasks (Dict[int, Task]): In-memory storage for tasks, using task ID as the key
                                  for efficient lookups.
        _next_id (int): A counter to generate unique IDs for new tasks.
    """

    def __init__(self):
        """Initializes the TaskManager with an empty task list."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        print("TaskManager initialized.")

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the collection.

        Args:
            task_name: The name of the task. Cannot be empty or whitespace.
            task_description: A description for the task.

        Returns:
            The unique ID of the newly created task.

        Raises:
            InvalidTaskDataError: If the task_name is invalid.
        """
        if not isinstance(task_name, str) or not task_name.strip():
            raise InvalidTaskDataError("Task name cannot be empty or just whitespace.")
        if not isinstance(task_description, str):
            raise InvalidTaskDataError("Task description must be a string.")

        task_id = self._next_id
        new_task: Task = {
            "id": task_id,
            "name": task_name.strip(),
            "description": task_description.strip(),
            "is_finished": False,
        }
        self._tasks[task_id] = new_task
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its ID.

        Args:
            task_id: The ID of the task to remove.

        Returns:
            True if the task was successfully removed.

        Raises:
            ValueError: If task_id is not a positive integer.
            TaskNotFoundError: If no task with the given ID exists.
        """
        self._validate_task_id(task_id)
        del self._tasks[task_id]
        return True

    def search(self, search_term: str) -> List[dict]:
        """
        Searches for tasks where the search term appears in the name or description.
        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of task dictionaries that match the search criteria.
            Returns an empty list if the search term is empty or no tasks match.
        """
        if not isinstance(search_term, str) or not search_term.strip():
            return []

        lower_term = search_term.lower()
        
        # Return copies to prevent external modification of internal state
        return [
            task.copy() for task in self._tasks.values()
            if lower_term in task["name"].lower() or lower_term in task["description"].lower()
        ]

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished.

        Raises:
            ValueError: If task_id is not a positive integer.
            TaskNotFoundError: If no task with the given ID exists.
        """
        self._validate_task_id(task_id)
        if self._tasks[task_id]["is_finished"]:
            # Idempotency: already finished, so it's a success.
            return True
        self._tasks[task_id]["is_finished"] = True
        return True

    def get_all(self) -> List[dict]:
        """
        Retrieves all tasks.

        Returns:
            A list containing all task dictionaries.
        """
        # Return copies to prevent external modification of internal state
        return [task.copy() for task in self._tasks.values()]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the manager.

        Returns:
            True upon successful clearing of all tasks.
        """
        self._tasks.clear()
        self._next_id = 1
        return True

    def _validate_task_id(self, task_id: int) -> None:
        """
        Internal helper to validate a task ID.

        Args:
            task_id: The ID to validate.

        Raises:
            ValueError: If task_id is not a positive integer.
            TaskNotFoundError: If the task_id does not exist in the task list.
        """
        if not isinstance(task_id, int) or task_id <= 0:
            raise ValueError("Task ID must be a positive integer.")
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task with ID '{task_id}' not found.")


# --- Console User Interface (Presentation Layer) ---

def print_task(task: dict):
    """Helper function to format and print a single task."""
    status = "Finished" if task["is_finished"] else "Pending"
    print(
        f"  ID: {task['id']} | Status: {status}\n"
        f"  Name: {task['name']}\n"
        f"  Description: {task['description']}\n"
        f"  -----------------------------------"
    )

def print_menu():
    """Prints the main menu for the application."""
    print("\n--- Todo List Menu ---")
    print("1. Add Task")
    print("2. List All Tasks")
    print("3. Finish Task")
    print("4. Remove Task")
    print("5. Search Tasks")
    print("6. Clear All Tasks")
    print("7. Exit")
    print("----------------------")

def main():
    """Main function to run the console-based UI for the TaskManager."""
    task_manager = TaskManager()

    # Pre-populate with some data for demonstration
    task_manager.add("Implement Core Logic", "Write the TaskManager class with all methods.")
    task_manager.add("Write UI", "Create the console interface in the main function.")
    task_manager.add("Add Documentation", "Ensure all code has docstrings and comments.")
    task_manager.finish(3) # Mark 'Add Documentation' as finished

    while True:
        print_menu()
        choice = input("Enter your choice: ")

        try:
            if choice == "1": # Add
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = task_manager.add(name, desc)
                print(f"\n[SUCCESS] Task added with ID: {task_id}")

            elif choice == "2": # List All
                tasks = task_manager.get_all()
                print("\n--- All Tasks ---")
                if not tasks:
                    print("No tasks found.")
                else:
                    for task in tasks:
                        print_task(task)

            elif choice == "3": # Finish
                task_id_str = input("Enter the ID of the task to finish: ")
                task_manager.finish(int(task_id_str))
                print(f"\n[SUCCESS] Task {task_id_str} marked as finished.")

            elif choice == "4": # Remove
                task_id_str = input("Enter the ID of the task to remove: ")
                task_manager.remove(int(task_id_str))
                print(f"\n[SUCCESS] Task {task_id_str} removed.")

            elif choice == "5": # Search
                term = input("Enter search term: ")
                results = task_manager.search(term)
                print(f"\n--- Search Results for '{term}' ---")
                if not results:
                    print("No matching tasks found.")
                else:
                    for task in results:
                        print_task(task)

            elif choice == "6": # Clear All
                confirm = input("Are you sure you want to delete all tasks? (y/n): ").lower()
                if confirm == 'y':
                    task_manager.clear_all()
                    print("\n[SUCCESS] All tasks have been cleared.")
                else:
                    print("\nOperation cancelled.")

            elif choice == "7": # Exit
                print("Exiting application. Goodbye!")
                sys.exit(0)

            else:
                print("\n[ERROR] Invalid choice. Please select a valid option.")

        except (TaskNotFoundError, InvalidTaskDataError) as e:
            print(f"\n[ERROR] {e}")
        except ValueError:
            print("\n[ERROR] Invalid input. Please enter a valid number for the task ID.")
        except Exception as e:
            print(f"\n[UNEXPECTED ERROR] An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()
```