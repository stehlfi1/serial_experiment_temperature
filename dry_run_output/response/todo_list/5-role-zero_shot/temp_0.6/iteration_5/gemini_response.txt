Of course. As a senior software developer, I will provide a high-quality Python implementation for a console-based todo list application. The solution will be structured using Object-Oriented Programming (OOP) and will adhere to the principles of the ISO/IEC 25010 standard for software quality.

### Design Philosophy (Adhering to ISO/IEC 25010)

Before presenting the code, here's a brief breakdown of how the design maps to the ISO/IEC 25010 quality characteristics:

*   **Functional Suitability:** The `TaskManager` class provides all required functionalities (add, remove, search, finish, get_all, clear_all) accurately and completely.
*   **Performance Efficiency:** The core data structure is a dictionary (`dict`), enabling O(1) average time complexity for ID-based operations like adding, removing, and finishing tasks. Search operations are O(n), which is optimal without a more complex indexing system.
*   **Maintainability:**
    *   **Modularity:** The logic is encapsulated within the `TaskManager` class. A separate `Task` dataclass is used for the data model, and private helper methods (`_validate_task_id`, `_task_to_dict`) prevent code duplication.
    *   **Readability:** The code uses descriptive variable names, comprehensive docstrings (following Google's style), and type hints for clarity.
    *   **Testability:** The `TaskManager` is a self-contained unit with no external dependencies (like files or databases), making it trivial to instantiate and test its methods.
*   **Reliability & Safety:**
    *   **Fault Tolerance:** The code gracefully handles predictable errors (e.g., non-existent IDs) by returning boolean statuses.
    *   **Robustness:** Invalid inputs (e.g., empty strings, wrong types) raise appropriate built-in exceptions (`ValueError`, `TypeError`), preventing the application from entering an invalid state.
*   **Usability:** While the core logic is backend-focused, the provided `main` block demonstrates a clear and simple command-line interface for user interaction.

---

### Python Implementation

Here is the complete, high-quality Python code for the `TaskManager`.

```python
"""
A high-quality, maintainable implementation of a console-based Todo List Manager.

This module provides a TaskManager class that adheres to the principles of the
ISO/IEC 25010 standard, focusing on correctness, efficiency, maintainability,
and safety.
"""
from __future__ import annotations

import dataclasses
from typing import Any, Dict, List


@dataclasses.dataclass
class Task:
    """
    Represents a single task in the todo list.

    Attributes:
        id: A unique integer identifier for the task.
        name: The name or title of the task.
        description: A more detailed description of the task.
        is_finished: A boolean indicating if the task is completed.
    """
    id: int
    name: str
    description: str
    is_finished: bool = False


class TaskManager:
    """
    Manages a collection of tasks with functionalities to add, remove, and query.

    This class uses an in-memory dictionary for efficient data storage and
    retrieval, ensuring high performance for key-based operations.
    """

    def __init__(self) -> None:
        """Initializes the TaskManager with an empty task list."""
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1

    def _validate_task_id(self, task_id: int) -> None:
        """
        Private helper to validate a task ID.

        Args:
            task_id: The ID to validate.

        Raises:
            TypeError: If task_id is not an integer.
            ValueError: If no task with the given ID exists.
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer.")
        if task_id not in self._tasks:
            raise ValueError(f"Task with ID '{task_id}' not found.")

    def _task_to_dict(self, task: Task) -> Dict[str, Any]:
        """
        Converts a Task object to its dictionary representation.

        This ensures a consistent output format for all public methods.

        Args:
            task: The Task object to convert.

        Returns:
            A dictionary representing the task.
        """
        return dataclasses.asdict(task)

    def add(self, task_name: str, task_description: str) -> int:
        """
        Adds a new task to the manager.

        Args:
            task_name: The name of the task. Must be a non-empty string.
            task_description: The description of the task.

        Returns:
            The unique ID assigned to the newly created task.

        Raises:
            ValueError: If task_name is an empty or whitespace-only string.
            TypeError: If task_name or task_description are not strings.
        """
        if not isinstance(task_name, str) or not isinstance(task_description, str):
            raise TypeError("Task name and description must be strings.")
        if not task_name.strip():
            raise ValueError("Task name cannot be empty.")

        task_id = self._next_id
        new_task = Task(
            id=task_id,
            name=task_name.strip(),
            description=task_description.strip(),
        )
        self._tasks[task_id] = new_task
        self._next_id += 1
        return task_id

    def remove(self, task_id: int) -> bool:
        """
        Removes a task by its ID.

        Args:
            task_id: The unique ID of the task to remove.

        Returns:
            True if the task was successfully removed, False otherwise.
        
        Raises:
            TypeError: If task_id is not an integer.
        """
        try:
            self._validate_task_id(task_id)
            del self._tasks[task_id]
            return True
        except ValueError:
            # As per the requirements, return a boolean for non-existent tasks.
            return False

    def finish(self, task_id: int) -> bool:
        """
        Marks a task as finished.

        Args:
            task_id: The unique ID of the task to mark as finished.

        Returns:
            True if the task was successfully marked as finished, False otherwise.
        
        Raises:
            TypeError: If task_id is not an integer.
        """
        try:
            self._validate_task_id(task_id)
            self._tasks[task_id].is_finished = True
            return True
        except ValueError:
            return False

    def search(self, search_term: str) -> List[Dict[str, Any]]:
        """
        Searches for tasks by a search term in their name or description.

        The search is case-insensitive.

        Args:
            search_term: The string to search for.

        Returns:
            A list of dictionaries, where each dictionary represents a matching task.

        Raises:
            ValueError: If search_term is an empty or whitespace-only string.
            TypeError: If search_term is not a string.
        """
        if not isinstance(search_term, str):
            raise TypeError("Search term must be a string.")
        if not search_term.strip():
            raise ValueError("Search term cannot be empty.")

        normalized_term = search_term.lower().strip()
        
        results = [
            self._task_to_dict(task)
            for task in self._tasks.values()
            if normalized_term in task.name.lower()
            or normalized_term in task.description.lower()
        ]
        return results

    def get_all(self) -> List[Dict[str, Any]]:
        """
        Retrieves all tasks.

        Returns:
            A list of dictionaries, representing all tasks in the manager.
        """
        return [self._task_to_dict(task) for task in self._tasks.values()]

    def clear_all(self) -> bool:
        """
        Deletes all tasks from the manager.

        Returns:
            True, indicating the operation was successful.
        """
        self._tasks.clear()
        self._next_id = 1  # Reset the ID counter
        return True


# --- Example Usage ---
def print_tasks(tasks: List[Dict[str, Any]]) -> None:
    """Helper function to neatly print a list of tasks."""
    if not tasks:
        print("No tasks found.")
        return
    for task in tasks:
        status = "Finished" if task['is_finished'] else "Pending"
        print(
            f"  ID: {task['id']}, Status: {status}\n"
            f"  Name: {task['name']}\n"
            f"  Description: {task['description']}\n"
            f"  ----------------"
        )


def main() -> None:
    """Main function to run the interactive console-based todo app."""
    manager = TaskManager()
    print("--- Console Todo List App ---")

    # Pre-populate with some data for demonstration
    manager.add("Buy groceries", "Milk, Bread, Cheese, and Eggs")
    manager.add("Finish report", "Complete the Q3 financial report for the meeting.")
    manager.add("Call mom", "Check in and see how she's doing.")

    while True:
        print("\nAvailable commands: [list, add, find, finish, remove, clear, exit]")
        command = input("Enter a command: ").lower().strip()

        try:
            if command == "list":
                print("\n--- All Tasks ---")
                print_tasks(manager.get_all())
            elif command == "add":
                name = input("Enter task name: ")
                desc = input("Enter task description: ")
                task_id = manager.add(name, desc)
                print(f"Successfully added task with ID: {task_id}")
            elif command == "find":
                term = input("Enter search term: ")
                print(f"\n--- Search Results for '{term}' ---")
                print_tasks(manager.search(term))
            elif command == "finish":
                task_id_str = input("Enter task ID to mark as finished: ")
                if manager.finish(int(task_id_str)):
                    print(f"Task {task_id_str} marked as finished.")
                else:
                    print(f"Error: Task {task_id_str} not found.")
            elif command == "remove":
                task_id_str = input("Enter task ID to remove: ")
                if manager.remove(int(task_id_str)):
                    print(f"Task {task_id_str} removed.")
                else:
                    print(f"Error: Task {task_id_str} not found.")
            elif command == "clear":
                confirm = input("Are you sure you want to delete all tasks? (y/n): ")
                if confirm.lower() == 'y':
                    manager.clear_all()
                    print("All tasks have been cleared.")
            elif command == "exit":
                print("Exiting application. Goodbye!")
                break
            else:
                print("Invalid command. Please try again.")
        except (ValueError, TypeError) as e:
            print(f"Error: {e}")
        except KeyboardInterrupt:
            print("\nExiting application. Goodbye!")
            break


if __name__ == "__main__":
    main()
```