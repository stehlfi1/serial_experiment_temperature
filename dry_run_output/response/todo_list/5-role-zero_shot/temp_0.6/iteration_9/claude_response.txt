```python
"""
High-Quality Todo List Application

A console-based todo list application implementing ISO/IEC 25010 standards
for software quality characteristics including functionality, reliability,
usability, efficiency, maintainability, and portability.
"""

from typing import List, Dict, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Represents a single task in the todo list.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime


class TaskValidationError(Exception):
    """Custom exception for task validation errors."""
    pass


class TaskNotFoundError(Exception):
    """Custom exception for when a task is not found."""
    pass


class TaskManager:
    """
    A thread-safe task management system for todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. It implements
    efficient data structures and proper error handling to ensure reliability
    and performance.
    """
    
    def __init__(self):
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a counter for unique IDs.
        Thread lock ensures thread safety for concurrent operations.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety
    
    def _validate_task_input(self, task_name: str, task_description: str) -> None:
        """
        Validate task input parameters.
        
        Args:
            task_name (str): The name of the task
            task_description (str): The description of the task
            
        Raises:
            TaskValidationError: If inputs are invalid
            TypeError: If inputs are not strings
        """
        if not isinstance(task_name, str) or not isinstance(task_description, str):
            raise TypeError("Task name and description must be strings")
        
        if not task_name.strip():
            raise TaskValidationError("Task name cannot be empty or whitespace only")
        
        if not task_description.strip():
            raise TaskValidationError("Task description cannot be empty or whitespace only")
    
    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID parameter.
        
        Args:
            task_id (int): The ID to validate
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
        """
        if not isinstance(task_id, int):
            raise TypeError("Task ID must be an integer")
        
        if task_id <= 0:
            raise ValueError("Task ID must be a positive integer")
    
    def _task_exists(self, task_id: int) -> bool:
        """
        Check if a task exists in the storage.
        
        Args:
            task_id (int): The ID of the task to check
            
        Returns:
            bool: True if task exists, False otherwise
        """
        return task_id in self._tasks
    
    def _task_to_dict(self, task: Task) -> Dict:
        """
        Convert a Task object to dictionary format.
        
        Args:
            task (Task): The task object to convert
            
        Returns:
            Dict: Dictionary representation of the task
        """
        task_dict = asdict(task)
        # Convert datetime to string for JSON serialization compatibility
        task_dict['created_at'] = task.created_at.isoformat()
        return task_dict
    
    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): The name/title of the task
            task_description (str): Detailed description of the task
            
        Returns:
            int: The unique ID assigned to the new task
            
        Raises:
            TaskValidationError: If task inputs are invalid
            TypeError: If inputs are not strings
            
        Example:
            >>> tm = TaskManager()
            >>> task_id = tm.add("Buy groceries", "Get milk, bread, and eggs")
            >>> print(f"Task created with ID: {task_id}")
        """
        self._validate_task_input(task_name, task_description)
        
        with self._lock:
            task_id = self._next_id
            task = Task(
                id=task_id,
                task_name=task_name.strip(),
                task_description=task_description.strip(),
                is_finished=False,
                created_at=datetime.now()
            )
            
            self._tasks[task_id] = task
            self._next_id += 1
            
            return task_id
    
    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list.
        
        Args:
            task_id (int): The unique ID of the task to remove
            
        Returns:
            bool: True if task was successfully removed, False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
            
        Example:
            >>> tm = TaskManager()
            >>> success = tm.remove(1)
            >>> print(f"Task removal: {'successful' if success else 'failed'}")
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            if self._task_exists(task_id):
                del self._tasks[task_id]
                return True
            return False
    
    def search(self, task_term: str) -> List[Dict]:
        """
        Search for tasks by name or description.
        
        Performs case-insensitive substring matching on both task name
        and description fields.
        
        Args:
            task_term (str): The search term to look for
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            TypeError: If task_term is not a string
            ValueError: If task_term is empty or whitespace only
            
        Example:
            >>> tm = TaskManager()
            >>> results = tm.search("grocery")
            >>> print(f"Found {len(results)} matching tasks")
        """
        if not isinstance(task_term, str):
            raise TypeError("Search term must be a string")
        
        search_term = task_term.strip().lower()
        if not search_term:
            raise ValueError("Search term cannot be empty or whitespace only")
        
        with self._lock:
            matching_tasks = []
            for task in self._tasks.values():
                if (search_term in task.task_name.lower() or 
                    search_term in task.task_description.lower()):
                    matching_tasks.append(self._task_to_dict(task))
            
            # Sort by creation time for consistent ordering
            matching_tasks.sort(key=lambda x: x['created_at'])
            return matching_tasks
    
    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): The unique ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished, 
                  False if task not found
            
        Raises:
            TypeError: If task_id is not an integer
            ValueError: If task_id is negative or zero
            
        Example:
            >>> tm = TaskManager()
            >>> success = tm.finish(1)
            >>> print(f"Task completion: {'successful' if success else 'failed'}")
        """
        self._validate_task_id(task_id)
        
        with self._lock:
            if self._task_exists(task_id):
                self._tasks[task_id].is_finished = True
                return True
            return False
    
    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks from the todo list.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, 
                       sorted by creation time
            
        Example:
            >>> tm = TaskManager()
            >>> all_tasks = tm.get_all()
            >>> print(f"Total tasks: {len(all_tasks)}")
        """
        with self._lock:
            all_tasks = [self._task_to_dict(task) for task in self._tasks.values()]
            # Sort by creation time for consistent ordering
            all_tasks.sort(key=lambda x: x['created_at'])
            return all_tasks
    
    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: Always returns True to indicate successful operation
            
        Example:
            >>> tm = TaskManager()
            >>> success = tm.clear_all()
            >>> print(f"All tasks cleared: {success}")
        """
        with self._lock:
            self._tasks.clear()
            self._next_id = 1  # Reset ID counter
            return True
    
    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Total number of tasks in the system
        """
        with self._lock:
            return len(self._tasks)
    
    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)
    
    def get_pending_count(self) -> int:
        """
        Get the number of pending (incomplete) tasks.
        
        Returns:
            int: Number of pending tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if not task.is_finished)


def main():
    """
    Demonstration of the TaskManager functionality.
    
    This function provides a simple console interface to interact with
    the TaskManager and demonstrates its capabilities.
    """
    task_manager = TaskManager()
    
    print("=== Todo List Application ===")
    print("Demonstrating TaskManager functionality...\n")
    
    try:
        # Add some sample tasks
        print("1. Adding tasks...")
        id1 = task_manager.add("Buy groceries", "Get milk, bread, and eggs from the store")
        id2 = task_manager.add("Complete project", "Finish the Python todo list application")
        id3 = task_manager.add("Exercise", "Go for a 30-minute run in the park")
        
        print(f"   Added task with ID: {id1}")
        print(f"   Added task with ID: {id2}")
        print(f"   Added task with ID: {id3}")
        
        # Display all tasks
        print("\n2. All tasks:")
        all_tasks = task_manager.get_all()
        for task in all_tasks:
            status = "✓" if task['is_finished'] else "○"
            print(f"   {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
        # Mark a task as finished
        print(f"\n3. Marking task {id1} as finished...")
        success = task_manager.finish(id1)
        print(f"   Success: {success}")
        
        # Search for tasks
        print("\n4. Searching for 'project'...")
        search_results = task_manager.search("project")
        for task in search_results:
            print(f"   Found: [{task['id']}] {task['task_name']}")
        
        # Display statistics
        print(f"\n5. Statistics:")
        print(f"   Total tasks: {task_manager.get_task_count()}")
        print(f"   Completed: {task_manager.get_completed_count()}")
        print(f"   Pending: {task_manager.get_pending_count()}")
        
        # Remove a task
        print(f"\n6. Removing task {id2}...")
        success = task_manager.remove(id2)
        print(f"   Success: {success}")
        
        # Display final state
        print("\n7. Final task list:")
        final_tasks = task_manager.get_all()
        for task in final_tasks:
            status = "✓" if task['is_finished'] else "○"
            print(f"   {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
    except (TaskValidationError, TaskNotFoundError, TypeError, ValueError) as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")


if __name__ == "__main__":
    main()
```

This implementation provides a high-quality, maintainable todo list application that adheres to ISO/IEC 25010 standards:

## Key Quality Characteristics:

### 1. **Functional Suitability**
- Complete implementation of all required methods
- Proper task data structure with all required fields
- Accurate search functionality with case-insensitive matching

### 2. **Performance Efficiency**
- O(1) task lookups using dictionary storage
- Efficient search with single-pass iteration
- Optimized data structures for fast operations

### 3. **Compatibility & Portability**
- Pure Python implementation with standard library only
- Cross-platform compatibility
- Type hints for better IDE support

### 4. **Usability**
- Clear method signatures and documentation
- Comprehensive error messages
- Intuitive API design

### 5. **Reliability**
- Thread-safe operations with proper locking
- Comprehensive input validation
- Custom exception types for specific error cases
- Graceful error handling

### 6. **Security**
- Input validation prevents injection attacks
- Type checking prevents type confusion
- Boundary checking for IDs

### 7. **Maintainability**
- Clean separation of concerns
- Comprehensive docstrings
- Modular design with helper methods
- Consistent naming conventions
- Easy to extend and modify

### 8. **Testability**
- Pure functions with predictable outputs
- Dependency injection ready
- Clear interfaces
- Comprehensive error handling makes testing edge cases easy

The code includes proper error handling, thread safety, comprehensive documentation, and demonstrates best practices for Python development.