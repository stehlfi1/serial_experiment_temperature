```python
"""
High-Quality Todo List Application

A console-based todo list application implementing ISO/IEC 25010 standards
for software quality characteristics including functionality, reliability,
usability, efficiency, maintainability, and portability.
"""

from typing import Dict, List, Optional
import threading
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class Task:
    """
    Represents a single task in the todo list.
    
    Attributes:
        id (int): Unique identifier for the task
        task_name (str): Name/title of the task
        task_description (str): Detailed description of the task
        is_finished (bool): Completion status of the task
        created_at (datetime): Timestamp when task was created
    """
    id: int
    task_name: str
    task_description: str
    is_finished: bool
    created_at: datetime

    def to_dict(self) -> Dict:
        """Convert task to dictionary format for external consumption."""
        return {
            'id': self.id,
            'task_name': self.task_name,
            'task_description': self.task_description,
            'is_finished': self.is_finished
        }


class TaskValidationError(ValueError):
    """Custom exception for task validation errors."""
    pass


class TaskNotFoundError(KeyError):
    """Custom exception for when a task is not found."""
    pass


class TaskManager:
    """
    A thread-safe task manager for handling todo list operations.
    
    This class provides comprehensive task management functionality including
    adding, removing, searching, completing, and retrieving tasks. It implements
    efficient data structures and proper error handling to ensure reliability
    and performance.
    """

    def __init__(self):
        """
        Initialize the TaskManager with empty task storage.
        
        Uses a dictionary for O(1) lookups and a counter for unique ID generation.
        Thread safety is ensured using a threading lock.
        """
        self._tasks: Dict[int, Task] = {}
        self._next_id: int = 1
        self._lock = threading.RLock()  # Reentrant lock for thread safety

    def _validate_task_name(self, task_name: str) -> None:
        """
        Validate task name input.
        
        Args:
            task_name (str): The task name to validate
            
        Raises:
            TaskValidationError: If task name is invalid
        """
        if not isinstance(task_name, str):
            raise TaskValidationError("Task name must be a string")
        if not task_name or not task_name.strip():
            raise TaskValidationError("Task name cannot be empty or whitespace only")
        if len(task_name.strip()) > 100:
            raise TaskValidationError("Task name cannot exceed 100 characters")

    def _validate_task_description(self, task_description: str) -> None:
        """
        Validate task description input.
        
        Args:
            task_description (str): The task description to validate
            
        Raises:
            TaskValidationError: If task description is invalid
        """
        if not isinstance(task_description, str):
            raise TaskValidationError("Task description must be a string")
        if not task_description or not task_description.strip():
            raise TaskValidationError("Task description cannot be empty or whitespace only")
        if len(task_description.strip()) > 500:
            raise TaskValidationError("Task description cannot exceed 500 characters")

    def _validate_task_id(self, task_id: int) -> None:
        """
        Validate task ID input.
        
        Args:
            task_id (int): The task ID to validate
            
        Raises:
            TaskValidationError: If task ID is invalid
            TaskNotFoundError: If task ID doesn't exist
        """
        if not isinstance(task_id, int):
            raise TaskValidationError("Task ID must be an integer")
        if task_id <= 0:
            raise TaskValidationError("Task ID must be a positive integer")
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task with ID {task_id} not found")

    def _validate_search_term(self, search_term: str) -> None:
        """
        Validate search term input.
        
        Args:
            search_term (str): The search term to validate
            
        Raises:
            TaskValidationError: If search term is invalid
        """
        if not isinstance(search_term, str):
            raise TaskValidationError("Search term must be a string")
        if not search_term or not search_term.strip():
            raise TaskValidationError("Search term cannot be empty or whitespace only")

    def add(self, task_name: str, task_description: str) -> int:
        """
        Add a new task to the todo list.
        
        Args:
            task_name (str): Name of the task (1-100 characters)
            task_description (str): Description of the task (1-500 characters)
            
        Returns:
            int: Unique ID of the created task
            
        Raises:
            TaskValidationError: If input validation fails
            
        Example:
            >>> manager = TaskManager()
            >>> task_id = manager.add("Buy groceries", "Get milk, bread, and eggs")
            >>> print(task_id)
            1
        """
        # Validate inputs
        self._validate_task_name(task_name)
        self._validate_task_description(task_description)
        
        with self._lock:
            # Create new task with unique ID
            task = Task(
                id=self._next_id,
                task_name=task_name.strip(),
                task_description=task_description.strip(),
                is_finished=False,
                created_at=datetime.now()
            )
            
            # Store task and increment ID counter
            self._tasks[self._next_id] = task
            current_id = self._next_id
            self._next_id += 1
            
            return current_id

    def remove(self, task_id: int) -> bool:
        """
        Remove a task from the todo list.
        
        Args:
            task_id (int): Unique ID of the task to remove
            
        Returns:
            bool: True if task was successfully removed, False otherwise
            
        Raises:
            TaskValidationError: If task ID is invalid
            
        Example:
            >>> manager = TaskManager()
            >>> task_id = manager.add("Test task", "Test description")
            >>> success = manager.remove(task_id)
            >>> print(success)
            True
        """
        try:
            self._validate_task_id(task_id)
            
            with self._lock:
                del self._tasks[task_id]
                return True
                
        except (TaskValidationError, TaskNotFoundError):
            return False

    def search(self, search_term: str) -> List[Dict]:
        """
        Search for tasks by name or description.
        
        Performs case-insensitive substring matching on both task name
        and description fields.
        
        Args:
            search_term (str): Term to search for in task names and descriptions
            
        Returns:
            List[Dict]: List of matching tasks in dictionary format
            
        Raises:
            TaskValidationError: If search term is invalid
            
        Example:
            >>> manager = TaskManager()
            >>> manager.add("Buy groceries", "Get milk and bread")
            >>> results = manager.search("milk")
            >>> print(len(results))
            1
        """
        self._validate_search_term(search_term)
        
        search_term_lower = search_term.strip().lower()
        matching_tasks = []
        
        with self._lock:
            for task in self._tasks.values():
                # Case-insensitive search in both name and description
                if (search_term_lower in task.task_name.lower() or 
                    search_term_lower in task.task_description.lower()):
                    matching_tasks.append(task.to_dict())
        
        # Sort by task ID for consistent ordering
        return sorted(matching_tasks, key=lambda x: x['id'])

    def finish(self, task_id: int) -> bool:
        """
        Mark a task as completed.
        
        Args:
            task_id (int): Unique ID of the task to mark as finished
            
        Returns:
            bool: True if task was successfully marked as finished, False otherwise
            
        Raises:
            TaskValidationError: If task ID is invalid
            
        Example:
            >>> manager = TaskManager()
            >>> task_id = manager.add("Complete project", "Finish the todo app")
            >>> success = manager.finish(task_id)
            >>> print(success)
            True
        """
        try:
            self._validate_task_id(task_id)
            
            with self._lock:
                self._tasks[task_id].is_finished = True
                return True
                
        except (TaskValidationError, TaskNotFoundError):
            return False

    def get_all(self) -> List[Dict]:
        """
        Retrieve all tasks in the todo list.
        
        Returns:
            List[Dict]: List of all tasks in dictionary format, sorted by ID
            
        Example:
            >>> manager = TaskManager()
            >>> manager.add("Task 1", "Description 1")
            >>> manager.add("Task 2", "Description 2")
            >>> all_tasks = manager.get_all()
            >>> print(len(all_tasks))
            2
        """
        with self._lock:
            all_tasks = [task.to_dict() for task in self._tasks.values()]
        
        # Sort by task ID for consistent ordering
        return sorted(all_tasks, key=lambda x: x['id'])

    def clear_all(self) -> bool:
        """
        Delete all tasks from the todo list.
        
        Returns:
            bool: True if all tasks were successfully cleared
            
        Example:
            >>> manager = TaskManager()
            >>> manager.add("Task 1", "Description 1")
            >>> success = manager.clear_all()
            >>> print(success)
            True
            >>> print(len(manager.get_all()))
            0
        """
        with self._lock:
            self._tasks.clear()
            # Reset ID counter for clean slate
            self._next_id = 1
            return True

    def get_task_count(self) -> int:
        """
        Get the total number of tasks.
        
        Returns:
            int: Total number of tasks in the todo list
        """
        with self._lock:
            return len(self._tasks)

    def get_completed_count(self) -> int:
        """
        Get the number of completed tasks.
        
        Returns:
            int: Number of completed tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if task.is_finished)

    def get_pending_count(self) -> int:
        """
        Get the number of pending (incomplete) tasks.
        
        Returns:
            int: Number of pending tasks
        """
        with self._lock:
            return sum(1 for task in self._tasks.values() if not task.is_finished)


# Example usage and demonstration
if __name__ == "__main__":
    """
    Demonstration of the TaskManager functionality.
    """
    print("=== Todo List Application Demo ===\n")
    
    # Create task manager instance
    task_manager = TaskManager()
    
    try:
        # Add some sample tasks
        print("Adding tasks...")
        task1_id = task_manager.add("Buy groceries", "Get milk, bread, and eggs from the store")
        task2_id = task_manager.add("Complete project", "Finish the todo list application")
        task3_id = task_manager.add("Call dentist", "Schedule appointment for next week")
        
        print(f"Added task {task1_id}: Buy groceries")
        print(f"Added task {task2_id}: Complete project")
        print(f"Added task {task3_id}: Call dentist")
        print()
        
        # Display all tasks
        print("All tasks:")
        for task in task_manager.get_all():
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        print()
        
        # Mark a task as finished
        print("Marking task 1 as finished...")
        task_manager.finish(task1_id)
        print()
        
        # Search for tasks
        print("Searching for 'project':")
        search_results = task_manager.search("project")
        for task in search_results:
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        print()
        
        # Display statistics
        print("Task Statistics:")
        print(f"  Total tasks: {task_manager.get_task_count()}")
        print(f"  Completed: {task_manager.get_completed_count()}")
        print(f"  Pending: {task_manager.get_pending_count()}")
        print()
        
        # Remove a task
        print(f"Removing task {task3_id}...")
        task_manager.remove(task3_id)
        print()
        
        # Display final state
        print("Final task list:")
        for task in task_manager.get_all():
            status = "✓" if task['is_finished'] else "○"
            print(f"  {status} [{task['id']}] {task['task_name']}: {task['task_description']}")
        
    except (TaskValidationError, TaskNotFoundError) as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")
```

This implementation provides a comprehensive, high-quality todo list application that adheres to ISO/IEC 25010 standards:

## Key Quality Characteristics:

**1. Functional Suitability:**
- Implements all required methods with correct signatures
- Provides comprehensive task management functionality
- Includes proper input validation and error handling

**2. Performance Efficiency:**
- Uses dictionary for O(1) task lookups
- Efficient search implementation
- Minimal memory overhead with optimized data structures

**3. Compatibility:**
- Pure Python implementation with no external dependencies
- Compatible with Python 3.7+
- Thread-safe design for concurrent usage

**4. Usability:**
- Clear, intuitive method names and signatures
- Comprehensive documentation with examples
- Helpful error messages for debugging

**5. Reliability:**
- Robust error handling with custom exceptions
- Input validation for all methods
- Thread-safe operations with proper locking

**6. Security:**
- Input sanitization and validation
- Protection against invalid data types
- Safe handling of edge cases

**7. Maintainability:**
- Clean, modular code structure
- Comprehensive docstrings and comments
- Separation of concerns with helper methods
- Easy to extend and modify

**8. Portability:**
- Standard library only implementation
- Cross-platform compatibility
- No external dependencies

The code includes proper validation, efficient algorithms, comprehensive error handling, and extensive documentation to ensure it meets enterprise-level quality standards.